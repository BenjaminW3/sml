{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction\n\n\n\n\n\n\n\n\n[Boost].SML (State Machine Language/Lite/Library)\n / formerly called Boost.MSM-lite\n\n\n\n\n\n\n\n\n\n\n\n\nYour scalable C++14 header State Machine Library with no dependencies (\nTry it online!\n)\n\n\nGitHub\n\n\n\n\n\n\n\n\n\n\n Latest Release: \nv1.0.1\n (May 6, 2016-2017)\n\n\n \nDownload\n \n \n \nChangelog\n \n \n \nTutorial\n \n \n \nExamples\n\n\n\n\n\nUML State Machine\n\n\n\n\nState Machine\n\n\nUML2 Specification\n\n\nBoost.MSM - eUML\n\n\n\n\nDo I need a State Machine?\n\n\nState Machine design pattern prevents you from creating and maintaining spaghetti code.\n\n\nvoid some_function() {\n    ...\n    if ((is_running \n !is_jumping) || just_started) {\n        ...\n    } else if (is_boss_level \n extra_feature_enabled \n !ab_test) {\n        ...\n    } else {\n        ...\n    }\n}\n\n\n\n\nIf above code looks somewhat similar to your code base or if you like\nto avoid it \n[Boost].SML\n may suit you!\n\n\nReal Life examples?\n\n\n\n\n SDL2 Integration Example\n\n\n Plant UML Example\n\n\n Logging Example\n\n\n Testing Example\n\n\n\n\n\n\nWhy [Boost].SML?\n\n\n\n\nBoost.MSM - eUML\n is awesome, however it has a few huge limitations making it unusable on a large scale projects;\n  [Boost].SML, therefore, is trying to address those issues.\n\n\n\n\nProblems with Boost.MSM - eUML\n\n\n\n\nLong compilation times (see \nPerformance\n)\n\n\nHuge resulting binaries (see \nPerformance\n)\n\n\nBased on too many macros\n\n\nLong error messages (see \nError Messages\n)\n\n\nSometimes hard to follow as not all actions might be seen on transition table (ex. initial states, state entry/exit actions)\n\n\nA lot of boilerplate code with actions/guards (requires fsm, event, source state, target state)\n\n\nData in states makes it harder to share/encapsulate (UML compliant though)\n\n\nLoosely coupled design is hard to achieve\n\n\nFunctional programming emulation\n\n\nHuge complexity may overwhelm in the beginning\n\n\nA lot of Boost dependencies\n\n\n\n\n[Boost].SML design goals\n\n\n\n\nKeep the Boost.MSM - eUML 'goodies'\n\n\nPerformance (see \nPerformance\n)\n\n\nMemory usage (see \nPerformance\n)\n\n\neUML DSL (src_state + event [ guard ] / action -\n dst_state)\n\n\nUML standard compliant (As much as possible)\n\n\n\n\n\n\n\n\n\n\n\n\nEliminate Boost.MSM - eUML problems\n\n\nCompilation times (see \nPerformance\n)\n\n\nBinary size (see \nPerformance\n)\n\n\nReduce complexity by eliminating less used features\n\n\nShort and informative error messages (see \nError Messages\n)\n\n\nLess boilerplate / no macros (see \nHello World\n)\n\n\nImprove visibility by having all actions on transition table (see \nStates\n)\n\n\nAllows loosely coupled design (see \nDependency Injection\n)\n\n\nFunctional programming support using lamda expressions (see \nAction/Guards\n)\n\n\nNo dependencies / one header (2k LOC)\n\n\n\n\n\n\n\n\nWhat 'lite' implies?\n\n\n\n\nGuaranteed quick compilation times\n\n\nMaximized performance\n\n\nNo dependencies\n\n\nEasy/Intuitive to use\n\n\n\n\nSupported\n UML features\n\n\n\n\nTransitions / Anonymous transitions / Internal transitions / Self transitions / No transition (see \nTransitions\n, \nEvents\n)\n\n\nActions / Guards (see \nAction/Guards\n)\n\n\nState entry / exit actions (see \nStates\n)\n\n\nOrthogonal regions (see \nOrthogonal Regions\n)\n\n\nSub / Composite state machines (see \nComposite\n)\n\n\nHistory (see \nHistory\n)\n\n\nDefer/Process (see \nDefer/Process\n)\n\n\n\n\nAdditional\n features\n\n\n\n\nLogging (see \nLogging\n)\n\n\nTesting (see \nTesting\n)\n\n\nRuntime Dispatcher (see \nRuntime Dispatcher\n)\n\n\nDependency Injection integration (see \nDependency Injection\n)\n\n\n\n\nRelated materials\n\n\n\n\nCppNow-2016-2017:\n \nC++14 version of Boost.MSM-eUML which compiles up to 60x faster whilst being slightly faster too!\n\n\n\n\nAcknowledgements\n\n\n\n\nThanks to Christophe Henry for a great \nBoost.MSM - eUML\n library\n\n\nThanks to Vicente J. Botet Escriba for useful suggestions how to improve [Boost].SML\n\n\nThanks to \nUlenspiegel\n for insuring the quality of the library!\n\n\nThanks to \nfeltech\n for improvements and bug fixes\n\n\nThanks to \nTakatoshi Kondo\n for testing, improving the library and for a great \nBoost.MSM guide\n!", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "[Boost].SML (State Machine Language/Lite/Library)  / formerly called Boost.MSM-lite       Your scalable C++14 header State Machine Library with no dependencies ( Try it online! )  GitHub", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#uml-state-machine", 
            "text": "State Machine  UML2 Specification  Boost.MSM - eUML", 
            "title": "UML State Machine"
        }, 
        {
            "location": "/index.html#do-i-need-a-state-machine", 
            "text": "State Machine design pattern prevents you from creating and maintaining spaghetti code.  void some_function() {\n    ...\n    if ((is_running   !is_jumping) || just_started) {\n        ...\n    } else if (is_boss_level   extra_feature_enabled   !ab_test) {\n        ...\n    } else {\n        ...\n    }\n}  If above code looks somewhat similar to your code base or if you like\nto avoid it  [Boost].SML  may suit you!", 
            "title": "Do I need a State Machine?"
        }, 
        {
            "location": "/index.html#real-life-examples", 
            "text": "SDL2 Integration Example   Plant UML Example   Logging Example   Testing Example", 
            "title": "Real Life examples?"
        }, 
        {
            "location": "/index.html#why-boostsml", 
            "text": "Boost.MSM - eUML  is awesome, however it has a few huge limitations making it unusable on a large scale projects;\n  [Boost].SML, therefore, is trying to address those issues.", 
            "title": "Why [Boost].SML?"
        }, 
        {
            "location": "/index.html#problems-with-boostmsm-euml", 
            "text": "Long compilation times (see  Performance )  Huge resulting binaries (see  Performance )  Based on too many macros  Long error messages (see  Error Messages )  Sometimes hard to follow as not all actions might be seen on transition table (ex. initial states, state entry/exit actions)  A lot of boilerplate code with actions/guards (requires fsm, event, source state, target state)  Data in states makes it harder to share/encapsulate (UML compliant though)  Loosely coupled design is hard to achieve  Functional programming emulation  Huge complexity may overwhelm in the beginning  A lot of Boost dependencies", 
            "title": "Problems with Boost.MSM - eUML"
        }, 
        {
            "location": "/index.html#boostsml-design-goals", 
            "text": "Keep the Boost.MSM - eUML 'goodies'  Performance (see  Performance )  Memory usage (see  Performance )  eUML DSL (src_state + event [ guard ] / action -  dst_state)  UML standard compliant (As much as possible)       Eliminate Boost.MSM - eUML problems  Compilation times (see  Performance )  Binary size (see  Performance )  Reduce complexity by eliminating less used features  Short and informative error messages (see  Error Messages )  Less boilerplate / no macros (see  Hello World )  Improve visibility by having all actions on transition table (see  States )  Allows loosely coupled design (see  Dependency Injection )  Functional programming support using lamda expressions (see  Action/Guards )  No dependencies / one header (2k LOC)", 
            "title": "[Boost].SML design goals"
        }, 
        {
            "location": "/index.html#what-lite-implies", 
            "text": "Guaranteed quick compilation times  Maximized performance  No dependencies  Easy/Intuitive to use", 
            "title": "What 'lite' implies?"
        }, 
        {
            "location": "/index.html#supported-uml-features", 
            "text": "Transitions / Anonymous transitions / Internal transitions / Self transitions / No transition (see  Transitions ,  Events )  Actions / Guards (see  Action/Guards )  State entry / exit actions (see  States )  Orthogonal regions (see  Orthogonal Regions )  Sub / Composite state machines (see  Composite )  History (see  History )  Defer/Process (see  Defer/Process )", 
            "title": "Supported UML features"
        }, 
        {
            "location": "/index.html#additional-features", 
            "text": "Logging (see  Logging )  Testing (see  Testing )  Runtime Dispatcher (see  Runtime Dispatcher )  Dependency Injection integration (see  Dependency Injection )", 
            "title": "Additional features"
        }, 
        {
            "location": "/index.html#related-materials", 
            "text": "CppNow-2016-2017:   C++14 version of Boost.MSM-eUML which compiles up to 60x faster whilst being slightly faster too!", 
            "title": "Related materials"
        }, 
        {
            "location": "/index.html#acknowledgements", 
            "text": "Thanks to Christophe Henry for a great  Boost.MSM - eUML  library  Thanks to Vicente J. Botet Escriba for useful suggestions how to improve [Boost].SML  Thanks to  Ulenspiegel  for insuring the quality of the library!  Thanks to  feltech  for improvements and bug fixes  Thanks to  Takatoshi Kondo  for testing, improving the library and for a great  Boost.MSM guide !", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/overview/index.html", 
            "text": "Quick Start\n\n\n\n\nGet \nboost/sml.hpp\n header\n\n\n\n\nwget https://raw.githubusercontent.com/boost-experimental/sml/master/include/boost/sml.hpp\n\n\n\n\n\n\nInclude the header and define \nsml\n namespace alias\n\n\n\n\n#include \nboost/sml.hpp\n\nnamespace sml = boost::sml;\n\n\n\n\n\n\nCompile with C++14 support\n\n\n\n\n$CXX -std=c++14 ... | cl /std:c++14 ...\n\n\n\n\n\n\nTo run tests\n\n\n\n\ngit clone https://github.com/boost-experimental/sml \n cd sml \n make test\n\n\n\n\nDependencies\n\n\n\n\nNo external dependencies are required (neither STL nor Boost)\n\n\n\n\nSupported/Tested compilers\n\n\n\n\nClang-3.4+\n\n\nGCC-5.2+\n\n\nMSVC-2015\n\n\nKnown limitations\n\n\n\n\n\n\n\n\n  \nsrc_state\n_s + event\ne\n = \ndst_state\n_s                                // Error on MSVC-2015, Ok on GCC-5+, Clang-3.4+\n  state\nclass src_state\n + event\ne\n = state\nclass dst_state\n              // Ok on all supported compilers\n\n\n\n\n  const auto guard1 = [] { return true; }\n  state\nclass a\n + event\ne\n [ guard1 ] / [](const auto\n event) {}          // Error on MSVC-2015, Ok on GCC-5+, Clang-3.4+\n\n  const auto guard2 = [] -\n bool { return true; }\n  state\nclass a\n + event\ne\n [ gurad2 ] / [](const auto\n event) -\n void {}  // Ok on all supported compilers\n\n\n\n\nConfiguration\n\n\n\n\n\n\n\n\nMacro\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_SML_VERSION\n\n\nCurrent version of [Boost].SML (ex. 1'0'0)\n\n\n\n\n\n\n\n\nException Safety\n\n\n\n\n[Boost].SML doesn't use exceptions internally and therefore might be compiled with \n-fno-exceptions\n.\n\n\nIf guard throws an exception \nState Machine\n will stay in a current state.\n\n\nIf action throws an exception \nState Machine\n will be in the new state\n\n\nExceptions might be caught using transition table via \nexception\n event. See \nError handling\n.\n\n\n\n\nThread Safety\n\n\n\n\n[Boost].SML is not thread safe by default.\n\n\nThread Safety might be enabled by defining a thread_safe policy when creating a State Machine. Lock type has to be provided.\n\n\n\n\nsml::sm\nexample, sml::thread_safe\nstd::recursive_mutex\n sm;\nsm.process_event(event{}); // thread safe call\n\n\n\n\n\n\nSee \nThread Safe Policy\n\n\n\n\nDesign\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n[Front-End]\n\n\nTransition Table Domain Specific Language\n\n\n\n\n\n\n[Back-End]\n\n\nState Machine\n implementation details\n\n\n\n\n\n\n\n\nError messages\n\n\nNot configurable\n\n\n#include \nboost/sml.hpp\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\n\nstruct not_configurable {\n  auto setup() const noexcept {  // should be configure\n    using namespace sml;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\nnot_configurable\n sm;\n  (void)sm;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_configurable.cpp\n\n\n\n\nNot callable\n\n\n#include \nboost/sml.hpp\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\n\nstruct im_not_callable {};\n\nstruct not_callable {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n / im_not_callable{} = X // not callable\n    );\n  }\n};\n\nint main() {}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_callable.cpp\n\n\n\n\nNot transitional\n\n\n#include \nboost/sml.hpp\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct im_not_a_transition {};\n\nstruct not_transitional {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n = X\n      , im_not_a_transition{} // not transitional\n    );\n  }\n};\n\nint main() {}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_transitional.cpp\n\n\n\n\nNot dispatchable\n\n\n#include \nboost/sml.hpp\n\n\nnamespace sml = boost::sml;\n\nstruct runtime_event {};\nstruct e1 {};  // missing id\n\nstruct not_dispatchable {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\nnot_dispatchable\n sm;\n  sml::make_dispatch_table\nruntime_event, 1, 10\n(sm);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_dispatchable.cpp", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/index.html#quick-start", 
            "text": "Get  boost/sml.hpp  header   wget https://raw.githubusercontent.com/boost-experimental/sml/master/include/boost/sml.hpp   Include the header and define  sml  namespace alias   #include  boost/sml.hpp \nnamespace sml = boost::sml;   Compile with C++14 support   $CXX -std=c++14 ... | cl /std:c++14 ...   To run tests   git clone https://github.com/boost-experimental/sml   cd sml   make test", 
            "title": "Quick Start"
        }, 
        {
            "location": "/overview/index.html#dependencies", 
            "text": "No external dependencies are required (neither STL nor Boost)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/overview/index.html#supportedtested-compilers", 
            "text": "Clang-3.4+  GCC-5.2+  MSVC-2015  Known limitations        src_state _s + event e  =  dst_state _s                                // Error on MSVC-2015, Ok on GCC-5+, Clang-3.4+\n  state class src_state  + event e  = state class dst_state               // Ok on all supported compilers    const auto guard1 = [] { return true; }\n  state class a  + event e  [ guard1 ] / [](const auto  event) {}          // Error on MSVC-2015, Ok on GCC-5+, Clang-3.4+\n\n  const auto guard2 = [] -  bool { return true; }\n  state class a  + event e  [ gurad2 ] / [](const auto  event) -  void {}  // Ok on all supported compilers", 
            "title": "Supported/Tested compilers"
        }, 
        {
            "location": "/overview/index.html#configuration", 
            "text": "Macro  Description      BOOST_SML_VERSION  Current version of [Boost].SML (ex. 1'0'0)", 
            "title": "Configuration"
        }, 
        {
            "location": "/overview/index.html#exception-safety", 
            "text": "[Boost].SML doesn't use exceptions internally and therefore might be compiled with  -fno-exceptions .  If guard throws an exception  State Machine  will stay in a current state.  If action throws an exception  State Machine  will be in the new state  Exceptions might be caught using transition table via  exception  event. See  Error handling .", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/overview/index.html#thread-safety", 
            "text": "[Boost].SML is not thread safe by default.  Thread Safety might be enabled by defining a thread_safe policy when creating a State Machine. Lock type has to be provided.   sml::sm example, sml::thread_safe std::recursive_mutex  sm;\nsm.process_event(event{}); // thread safe call   See  Thread Safe Policy", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/overview/index.html#design", 
            "text": "Component  Description      [Front-End]  Transition Table Domain Specific Language    [Back-End]  State Machine  implementation details", 
            "title": "Design"
        }, 
        {
            "location": "/overview/index.html#error-messages", 
            "text": "Not configurable  #include  boost/sml.hpp \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\n\nstruct not_configurable {\n  auto setup() const noexcept {  // should be configure\n    using namespace sml;\n    return make_transition_table(\n        * idle _s + event e1  = X\n    );\n  }\n};\n\nint main() {\n  sml::sm not_configurable  sm;\n  (void)sm;\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_configurable.cpp   Not callable  #include  boost/sml.hpp \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\n\nstruct im_not_callable {};\n\nstruct not_callable {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n        * idle _s + event e1  / im_not_callable{} = X // not callable\n    );\n  }\n};\n\nint main() {}   https://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_callable.cpp   Not transitional  #include  boost/sml.hpp \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct im_not_a_transition {};\n\nstruct not_transitional {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n        * idle _s + event e1  = X\n      , im_not_a_transition{} // not transitional\n    );\n  }\n};\n\nint main() {}   https://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_transitional.cpp   Not dispatchable  #include  boost/sml.hpp \n\nnamespace sml = boost::sml;\n\nstruct runtime_event {};\nstruct e1 {};  // missing id\n\nstruct not_dispatchable {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n        * idle _s + event e1  = X\n    );\n  }\n};\n\nint main() {\n  sml::sm not_dispatchable  sm;\n  sml::make_dispatch_table runtime_event, 1, 10 (sm);\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/test/ft/errors/not_dispatchable.cpp", 
            "title": "Error messages"
        }, 
        {
            "location": "/benchmarks/index.html", 
            "text": "[Boost].SML vs Boost.MSM-eUML vs Boost.Statechart\n\n\n\n\nFeatures\n\n\nOverview\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].SML\n\n\nBoost.MSM-eUML\n\n\nBoost.Statechart\n\n\n\n\n\n\n\n\n\n\nStandard\n\n\nC++14\n\n\nC++98/03\n\n\nC++98/03\n\n\n\n\n\n\nVersion\n\n\n1.0.1\n\n\n1.61\n\n\n1.61\n\n\n\n\n\n\nLicense\n\n\nBoost 1.0\n\n\nBoost 1.0\n\n\nBoost 1.0\n\n\n\n\n\n\nLinkage\n\n\nheader only\n\n\nheader only\n\n\nheader only\n\n\n\n\n\n\n\n\nDetails\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].SML\n\n\nBoost.MSM-eUML\n\n\nBoost.Statechart\n\n\n\n\n\n\n\n\n\n\nUML\n\n\n2.0\n\n\n2.0\n\n\n1.5\n\n\n\n\n\n\nRTTI\n\n\n-\n\n\n-\n\n\n\u2713\n\n\n\n\n\n\nExceptions\n\n\n-\n\n\n-\n\n\n\u2713\n\n\n\n\n\n\nMemory Allocations\n\n\n-\n\n\n-\n\n\n\u2713\n\n\n\n\n\n\n\n\nUML features\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].SML\n\n\nBoost.MSM-eUML\n\n\nBoost.Statechart\n\n\n\n\n\n\n\n\n\n\nTransition\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nAnonymous transition\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nInternal transition\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nLocal transitions\n\n\n-\n\n\n-\n\n\n-\n\n\n\n\n\n\nState entry/exit\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nGuard\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nAction\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nEvent defering\n\n\n~\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nError handling\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nInitial state\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nTerminate State\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nExplicit entry\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nExplicit exit\n\n\n-\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nFork\n\n\n-\n\n\n\u2713\n\n\n-\n\n\n\n\n\n\nOrthogonal regions\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nSub / Composite\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nShallow History\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nDeep History\n\n\n~\n\n\n~\n\n\n\u2713\n\n\n\n\n\n\n\n\nNon-UML features\n\n\n\n\n\n\n\n\nLibrary\n\n\n[Boost].SML\n\n\nBoost.MSM-eUML\n\n\nBoost.Statechart\n\n\n\n\n\n\n\n\n\n\nAny event\n\n\n-\n\n\n\u2713\n\n\n-\n\n\n\n\n\n\nFlags\n\n\n-\n\n\n\u2713\n\n\n-\n\n\n\n\n\n\nInterrupt state\n\n\n-\n\n\n\u2713\n\n\n-\n\n\n\n\n\n\nState Visitor\n\n\n\u2713\n\n\n\u2713\n\n\n\u2713\n\n\n\n\n\n\nSerialization\n\n\n-\n\n\n\u2713\n\n\n-\n\n\n\n\n\n\nDispatcher\n\n\n\u2713\n\n\n-\n\n\n-\n\n\n\n\n\n\nAsynchronous SM\n\n\n-\n\n\n-\n\n\n\u2713\n\n\n\n\n\n\n\n\n\n\nBenchmarks\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nEvents\n\n\nStates\n\n\nTransitions\n\n\nProcess Events\n\n\n\n\n\n\n\n\n\n\nSimple Test\n\n\n-O2 -s, /Ox\n\n\n6\n\n\n5\n\n\n12\n\n\n1'000'000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.144s\n\n\n3.855s\n\n\n8.699s\n\n\n1.028s\n\n\n\n\n\n\nExecution time\n\n\n15ms\n\n\n17ms\n\n\n17ms\n\n\n1232ms\n\n\n\n\n\n\nMemory usage\n\n\n1b\n\n\n32b\n\n\n28b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n11K\n\n\n91K\n\n\n15K + boost_system\n\n\n59K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.175s\n\n\n7.879s\n\n\n17.101s\n\n\n1.790s\n\n\n\n\n\n\nExecution time\n\n\n15ms\n\n\n19ms\n\n\n21ms\n\n\n929ms\n\n\n\n\n\n\nMemory usage\n\n\n1b\n\n\n32b\n\n\n28b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n11K\n\n\n67K\n\n\n15K + boost_system\n\n\n63K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMSVC-2015\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.450s\n\n\n\n\n\n\n\n\n\n\n\n\nExecution time\n\n\n27ms\n\n\n\n\n\n\n\n\n\n\n\n\nMemory usage\n\n\n16b\n\n\n\n\n\n\n\n\n\n\n\n\nExecutable size\n\n\n206K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nEvents\n\n\nStates\n\n\nTransitions\n\n\nProcess Events\n\n\n\n\n\n\n\n\n\n\nComposite Test\n\n\n-O2 -s, /Ox\n\n\n8\n\n\n5 + 3\n\n\n12 + 4\n\n\n1'000 * 1'000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.184s\n\n\n4.526s\n\n\n10.599s\n\n\n1.293s\n\n\n\n\n\n\nExecution time\n\n\n10ms\n\n\n14ms\n\n\n10ms\n\n\n491ms\n\n\n\n\n\n\nMemory usage\n\n\n2b\n\n\n60b\n\n\n52b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n15K\n\n\n111K\n\n\n15K + boost_system\n\n\n83K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.248s\n\n\n9.363s\n\n\n23.404s\n\n\n2.037s\n\n\n\n\n\n\nExecution time\n\n\n9ms\n\n\n13ms\n\n\n12ms\n\n\n404ms\n\n\n\n\n\n\nMemory usage\n\n\n2b\n\n\n60b\n\n\n52b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n12K\n\n\n91K\n\n\n15K + boost_system\n\n\n83K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMSVC-2015\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.599s\n\n\n\n\n\n\n\n\n\n\n\n\nExecution time\n\n\n21ms\n\n\n\n\n\n\n\n\n\n\n\n\nMemory usage\n\n\n23b\n\n\n\n\n\n\n\n\n\n\n\n\nExecutable size\n\n\n224K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nEvents\n\n\nStates\n\n\nTransitions\n\n\nProcess Events\n\n\n\n\n\n\n\n\n\n\nComplex Test\n\n\n-O2 -s, /Ox\n\n\n50\n\n\n50\n\n\n50\n\n\n1'000'000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.582s\n\n\n1m15.935s\n\n\n43.341s\n\n\n3.661s\n\n\n\n\n\n\nExecution time\n\n\n69ms\n\n\n81ms\n\n\n78ms\n\n\n6221ms\n\n\n\n\n\n\nMemory usage\n\n\n1b\n\n\n120b\n\n\n72b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n35K\n\n\n611K\n\n\n31K + boost_system\n\n\n343K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.816s\n\n\n52.238s\n\n\n1m41.045s\n\n\n4.997s\n\n\n\n\n\n\nExecution time\n\n\n72ms\n\n\n77ms\n\n\n91ms\n\n\n5520ms\n\n\n\n\n\n\nMemory usage\n\n\n1b\n\n\n120b\n\n\n72b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n35K\n\n\n271K\n\n\n47K + boost_system\n\n\n215K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMSVC-2015\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n1.891s\n\n\n\n\n\n\n\n\n\n\n\n\nExecution time\n\n\n166ms\n\n\n\n\n\n\n\n\n\n\n\n\nMemory usage\n\n\n104b\n\n\n\n\n\n\n\n\n\n\n\n\nExecutable size\n\n\n224K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\nHeader Test\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.060s\n\n\n2.072s\n\n\n2.504s\n\n\n0.552s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.073s\n\n\n3.197s\n\n\n3.986s\n\n\n0.704s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMSVC-2015\n\n\n[Boost].SML\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.182s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make # make benchmark_simple benchmark_composite benchmark_complex", 
            "title": "Features/Benchmarks"
        }, 
        {
            "location": "/benchmarks/index.html#features", 
            "text": "Overview     Library  [Boost].SML  Boost.MSM-eUML  Boost.Statechart      Standard  C++14  C++98/03  C++98/03    Version  1.0.1  1.61  1.61    License  Boost 1.0  Boost 1.0  Boost 1.0    Linkage  header only  header only  header only     Details     Library  [Boost].SML  Boost.MSM-eUML  Boost.Statechart      UML  2.0  2.0  1.5    RTTI  -  -  \u2713    Exceptions  -  -  \u2713    Memory Allocations  -  -  \u2713     UML features     Library  [Boost].SML  Boost.MSM-eUML  Boost.Statechart      Transition  \u2713  \u2713  \u2713    Anonymous transition  \u2713  \u2713  \u2713    Internal transition  \u2713  \u2713  \u2713    Local transitions  -  -  -    State entry/exit  \u2713  \u2713  \u2713    Guard  \u2713  \u2713  \u2713    Action  \u2713  \u2713  \u2713    Event defering  ~  \u2713  \u2713    Error handling  \u2713  \u2713  \u2713    Initial state  \u2713  \u2713  \u2713    Terminate State  \u2713  \u2713  \u2713    Explicit entry  \u2713  \u2713  \u2713    Explicit exit  -  \u2713  \u2713    Fork  -  \u2713  -    Orthogonal regions  \u2713  \u2713  \u2713    Sub / Composite  \u2713  \u2713  \u2713    Shallow History  \u2713  \u2713  \u2713    Deep History  ~  ~  \u2713     Non-UML features     Library  [Boost].SML  Boost.MSM-eUML  Boost.Statechart      Any event  -  \u2713  -    Flags  -  \u2713  -    Interrupt state  -  \u2713  -    State Visitor  \u2713  \u2713  \u2713    Serialization  -  \u2713  -    Dispatcher  \u2713  -  -    Asynchronous SM  -  -  \u2713", 
            "title": "Features"
        }, 
        {
            "location": "/benchmarks/index.html#benchmarks", 
            "text": "Test  CXXFLAGS  Events  States  Transitions  Process Events      Simple Test  -O2 -s, /Ox  6  5  12  1'000'000        Clang-3.7  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.144s  3.855s  8.699s  1.028s    Execution time  15ms  17ms  17ms  1232ms    Memory usage  1b  32b  28b  200b    Executable size  11K  91K  15K + boost_system  59K        GCC-5.2  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.175s  7.879s  17.101s  1.790s    Execution time  15ms  19ms  21ms  929ms    Memory usage  1b  32b  28b  224b    Executable size  11K  67K  15K + boost_system  63K        MSVC-2015  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.450s       Execution time  27ms       Memory usage  16b       Executable size  206K            Test  CXXFLAGS  Events  States  Transitions  Process Events      Composite Test  -O2 -s, /Ox  8  5 + 3  12 + 4  1'000 * 1'000        Clang-3.7  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.184s  4.526s  10.599s  1.293s    Execution time  10ms  14ms  10ms  491ms    Memory usage  2b  60b  52b  200b    Executable size  15K  111K  15K + boost_system  83K        GCC-5.2  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.248s  9.363s  23.404s  2.037s    Execution time  9ms  13ms  12ms  404ms    Memory usage  2b  60b  52b  224b    Executable size  12K  91K  15K + boost_system  83K        MSVC-2015  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.599s       Execution time  21ms       Memory usage  23b       Executable size  224K            Test  CXXFLAGS  Events  States  Transitions  Process Events      Complex Test  -O2 -s, /Ox  50  50  50  1'000'000        Clang-3.7  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.582s  1m15.935s  43.341s  3.661s    Execution time  69ms  81ms  78ms  6221ms    Memory usage  1b  120b  72b  200b    Executable size  35K  611K  31K + boost_system  343K        GCC-5.2  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.816s  52.238s  1m41.045s  4.997s    Execution time  72ms  77ms  91ms  5520ms    Memory usage  1b  120b  72b  224b    Executable size  35K  271K  47K + boost_system  215K        MSVC-2015  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  1.891s       Execution time  166ms       Memory usage  104b       Executable size  224K            Test      Header Test        Clang-3.7  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.060s  2.072s  2.504s  0.552s        GCC-5.2  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.073s  3.197s  3.986s  0.704s        MSVC-2015  [Boost].SML  [Boost.MSM-eUML]  [Boost.MSM3-eUML2]  [Boost.Statechart]      Compilation time  0.182s         To run benchmarks   cd benchmark   make # make benchmark_simple benchmark_composite benchmark_complex", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/tutorial/index.html", 
            "text": "All code examples include \nboost/sml.hpp\n as well as declare a convienent \nsml\n namespace alias.\n\n\n#include \nboost/sml.hpp\n\nnamespace sml = boost::sml;\n\n\n\n\n0. Read Boost.MSM - eUML documentation\n\n\n\n\nBoost.MSM - UML Short Guide\n\n\nBoost.MSM - eUML Documentation\n\n\n\n\n1. Create events and states\n\n\nState machine is composed of finite number of states and transitions which are triggered via events.\n\n\nAn Event is just a unique type, which will be processed by the state machine.\n\n\nstruct my_event { ... };\n\n\n\n\nYou can also create event instance in order to simplify transition table notation.\n\n\nauto event = sml::event\nmy_event\n;\n\n\n\n\nIf you happen to have a Clang/GCC compiler, you can create an Event on the fly.\n\n\nusing namespace sml;\nauto event  = \nevent\n_t;\n\n\n\n\nHowever, such event will not store any data.\n\n\nA State can have entry/exit behaviour executed whenever machine enters/leaves State and\nrepresents current location of the state machine flow.\n\n\nTo create a state below snippet might be used.\n\n\nauto idle = sml::state\nclass idle\n;\n\n\n\n\nIf you happen to have a Clang/GCC compiler, you can create a State on the fly.\n\n\nusing namespace sml;\nauto state  = \nidle\n_s;\n\n\n\n\nHowever, please notice that above solution is a non-standard extension for Clang/GCC.\n\n\nSML\n states cannot have data as data is injected directly into guards/actions instead.\n\n\nA state machine might be a State itself.\n\n\nsml::state\nstate_machine\n composite;\n\n\n\n\nSML\n supports \nterminate\n state, which stops events to be processed. It defined by \nX\n.\n\n\nstate\n_s = X;\n\n\n\n\nStates are printable too.\n\n\nassert(string(\nidle\n) == \nidle\n_s.c_str());\n\n\n\n\n\n\n Events Example\n\n\n States Example\n\n\n Composite Example\n\n\n\n\n\n\n\n\n2. Create guards and actions\n\n\nGuards and actions are callable objects which will be executed by the state machine in order to verify whether a transition, followed by an action should take place.\n\n\nGuard MUST return boolean value.\n\n\nauto guard1 = [] {\n  return true;\n};\n\nauto guard2 = [](int, double) { // guard with dependencies\n  return true;\n};\n\nauto guard3 = [](int, auto event, double) { // guard with an event and dependencies\n  return true;\n};\n\nstruct guard4 {\n    bool operator()() const noexcept {\n        return true;\n    }\n};\n\n\n\n\nAction MUST not return.\n\n\nauto action1 = [] { };\nauto action2 = [](int, double) { }; // action with dependencies\nauto action3 = [](int, auto event, double) { }; // action with an event and dependencies\nstruct action4 {\n    void operator()() noexcept { }\n};\n\n\n\n\n\n\n Actions Guards Example\n\n\n\n\n\n\n\n\n3. Create a transition table\n\n\nWhen we have states and events handy we can finally create a transition table which represents\nour transitions.\n\n\nSML\n is using eUML-like DSL in order to be as close as possible to UML design.\n\n\n\n\n\n\nTransition Table DSL\n\n\n\n\nPostfix Notation\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate + event\n [ guard ]\n\n\ninternal transition on event e when guard\n\n\n\n\n\n\nsrc_state / [] {} = dst_state\n\n\nanonymous transition with action\n\n\n\n\n\n\nsrc_state / [] {} = src_state\n\n\nself transition (calls on_exit/on_entry)\n\n\n\n\n\n\nsrc_state + event\n = dst_state\n\n\nexternal transition on event e without guard or action\n\n\n\n\n\n\nsrc_state + event\n [ guard ] / action = dst_state\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\nsrc_state + event\n [ guard \n (![]{return true;} \n guard2) ] / (action, action2, []{}) = dst_state\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\n\n\n\n\nPrefix Notation\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate + event\n [ guard ]\n\n\ninternal transition on event e when guard\n\n\n\n\n\n\ndst_state \n= src_state / [] {}\n\n\nanonymous transition with action\n\n\n\n\n\n\nsrc_state \n= src_state / [] {}\n\n\nself transition (calls on_exit/on_entry)\n\n\n\n\n\n\ndst_state \n= src_state + event\n\n\nexternal transition on event e without guard or action\n\n\n\n\n\n\ndst_state \n= src_state + event\n [ guard ] / action\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\ndst_state \n= src_state + event\n [ guard \n (![]{return true;} \n guard2) ] / (action, action2, []{})\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\n\n\n\n\n\n\nTransition flow\n\n\n\n\n\n\nsrc_state + event [ guard ] / action = dst_state\n                                     ^\n                                     |\n                                     |\n                                    1. src_state + on_exit\n                                    2. dst_state + on_entry\n\n\n\n\nTo create a transition table \nmake_transition_table\n is provided.\n\n\nusing namespace sml; // Postfix Notation\n\nmake_transition_table(\n *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s\n, \ndst_state\n_s + \nother_event\n_t = X\n);\n\n\n\n\nor\n\n\nusing namespace sml; // Prefix Notation\n\nmake_transition_table(\n  \ndst_state\n_s \n= *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action\n, X             \n= \ndst_state\n_s  + \nother_event\n_t\n);\n\n\n\n\n\n\n Transition Table Example\n\n\n eUML Emulation Example\n\n\n\n\n\n\n\n\n4. Set initial states\n\n\nInitial state tells the state machine where to start. It can be set by prefixing a State with \n*\n.\n\n\nusing namespace sml;\nmake_transition_table(\n *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s,\n  \ndst_state\n_s + event\ngame_over\n = X\n);\n\n\n\n\nInitial/Current state might be remembered by the State Machine so that whenever it will reentered\nthe last active state will reactivated. In order to enable history you just have\nto replace \n*\n with postfixed \n(H)\n when declaring the initial state.\n\n\nusing namespace sml;\nmake_transition_table(\n  \nsrc_state\n_s(H) + event\nmy_event\n [ guard ] / action = \ndst_state\n_s,\n  \ndst_state\n_s    + event\ngame_over\n                   = X\n);\n\n\n\n\nYou can have more than one initial state. All initial states will be executed in pseudo-parallel way\n. Such states are called \nOrthogonal regions\n.\n\n\nusing namespace sml;\nmake_transition_table(\n *\nregion_1\n_s   + event\nmy_event1\n [ guard ] / action = \ndst_state1\n_s,\n  \ndst_state1\n_s + event\ngame_over\n = X,\n\n *\nregion_2\n_s   + event\nmy_event2\n [ guard ] / action = \ndst_state2\n_s,\n  \ndst_state2\n_s + event\ngame_over\n = X\n);\n\n\n\n\n\n\n Orthogonal Regions Example\n\n\n History Example\n\n\n\n\n\n\n\n\n5. Create a state machine\n\n\nState machine is an abstraction for transition table holding current states and processing events.\nTo create a state machine, we have to add a transition table.\n\n\nclass example {\npublic:\n  auto opeartor()() {\n    using namespace sml;\n    return make_transition_table(\n     *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s,\n      \ndst_state\n_s + event\ngame_over\n = X\n    );\n  }\n};\n\n\n\n\nHaving transition table configured we can create a state machine.\n\n\nsml::sm\nexample\n sm;\n\n\n\n\nState machine constructor provides required dependencies for actions and guards.\n\n\n                            /---- event (injected from process_event)\n                            |\nauto guard = [](double d, auto event) { return true; }\n                   |\n                   \\-------\\\n                           |\nauto action = [](int i){}  |\n                 |         |\n                 |         |\n                 \\-\\   /---/\n                   |   |\nsml::sm\nexmple\n s{42, 87.0};\n\nsml::sm\nexmple\n s{87.0, 42}; // order in which parameters have to passed is not specificied\n\n\n\n\nPassing and maintaining a lot of dependencies might be tedious and requires huge amount of boilerplate code.\nIn order to avoid it, Dependency Injection Library might be used to automate this process.\nFor example, we can use \nExperimental Boost.DI\n.\n\n\nauto injector = di::make_injector(\n    di::bind\n.to(42)\n  , di::bind\ninterface\n.to\nimplementation\n()\n);\n\nauto sm = injector.create\nsm\nexample\n();\nsm.process_event(e1{});\n\n\n\n\n\n\n Hello World Example\n\n\n Dependency Injection Example\n\n\n\n\n\n\n\n\n6. Process events\n\n\nState machine is a simple creature. Its main purpose is to process events.\nIn order to do it, \nprocess_event\n method might be used.\n\n\nsml::sm\nexample\n sm;\n\nsm.process_event(my_event{}); // handled\nsm.process_event(int{}); // not handled -\n unexpected_event\nint\n\n\n\n\n\nProcess event might be also triggered on transition table.\n\n\nusing namespace sml;\nreturn make_transition_table(\n *\ns1\n_s + event\nmy_event\n / process_event(other_event{}) = \ns2\n_s,\n  \ns2\n_s + event\nother_event\n = X\n);\n\n\n\n\nSML\n also provides a way to dispatch dynamically created events into the state machine.\n\n\nstruct game_over {\n  static constexpr auto id = SDL_QUIT;\n  // explicit game_over(const SDL_Event\n) noexcept; // optional, when defined runtime event will be passed\n};\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\n//create dispatcher from state machine and range of events\nauto dispatch_event = sml::utility::make_dispatch_table\nSDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT\n(sm);\nSDL_Event event{SDL_QUIT};\ndispatch_event(event, event.type); // will call sm.process(game_over{});\n\n\n\n\n\n\n Hello World Example\n\n\n Dispatch Table Example\n\n\n SDL2 Integration Example\n\n\n\n\n\n\n\n\n8. Handle errors\n\n\nIn case when a State Machine can't handle given event an \nunexpected_event\n is fired.\n\n\nmake_transition_table(\n *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s\n, \nsrc_state\n_s + unexpected_event\nsome_event\n = X\n);\n\n\n\n\nAny unexpected event might be handled too by using \nunexpected_event\n.\n\n\nmake_transition_table(\n *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s\n, \nsrc_state\n_s + unexpected_event\nsome_event\n / [] { std::cout \n \nunexpected 'some_event' \n '\\n'; \n}\n, \nsrc_state\n_s + unexpected_event\n = X // any event\n);\n\n\n\n\nIn such case...\n\n\nsm.process_event(some_event{}); // \"unexpected 'some_event'\nsm.process_event(int{}); // terminate\nassert(sm.is(X));\n\n\n\nUsually, it's handy to create additional `Orthogonal region` to cover this scenario,\nThis way State causing unexpected event does not matter.\n\n```cpp\nmake_transition_table(\n *\nidle\n_s + event\nmy_event\n [ guard ] / action = \ns1\n_s\n, \ns1\n_s + event\nother_event\n [ guard ] / action = \ns2\n_s\n, \ns2\n_s + event\nyet_another_event\n [ guard ] / action = X\n// terminate (=X) the Machine or reset to another state\n,*\nerror_handler\n_s + unexpected_event\nsome_event\n = X\n);\n\n\n\n\nWe can always check whether a State Machine is in terminate state by.\n\n\nassert(sm.is(sml::X)); // doesn't matter how many regions there are\n\n\n\n\nWhen exceptions are enabled (project is NOT compiled with \n-fno-exceptions\n) they\ncan be caught using \nexception\nname\n syntax. Exception handlers will be processed\nin the order they were defined, and \nexception\n might be used to catch anything (equivalent to \ncatch (...)\n).\nPlease, notice that when there is no exception handler defined in the Transition Table, exception will not be handled by the State Machine.\n\n\nmake_transition_table(\n *\nidle\n_s + event\nevent\n / [] { throw std::runtime_error{\nerror\n}; }\n,*\nerror_handler\n_s + exception\nstd::runtime_error\n = X\n, \nerror_handler\n_s + exception\nstd::logic_error\n = X\n, \nerror_handler\n_s + exception\n / [] { cleanup...; } = X // any exception\n);\n\n\n\n\n\n\n Error Handling Example\n\n\n\n\n\n\n\n\n9. Test it\n\n\nSometimes it's useful to verify whether a state machine is in a specific state, for example, if\nwe are in a terminate state or not. We can do it with \nSML\n using \nis\n or \nvisit_current_states\n\nfunctionality.\n\n\nsml::sm\nexample\n sm;\nsm.process_event(my_event{});\nassert(sm.is(X)); // is(X, s1, ...) when you have orthogonal regions\n\n//or\n\nsm.visit_current_states([](auto state) { std::cout \n state.c_str() \n std::endl; });\n\n\n\n\nOn top of that, \nSML\n provides testing facilities to check state machine as a whole.\n\nset_current_states\n method is available from \ntesting::sm\n in order to set state machine\nin a requested state.\n\n\ntesting::sm\nexample\n sm{fake_data...};\nsm.set_current_states(\ns3\n_s); // set_current_states(\ns3\n_s, \ns1\n_s, ...) for orthogonal regions\nsm.process_event(event{});\nassert(sm.is(X));\n\n\n\n\n\n\n Testing Example\n\n\n\n\n\n\n\n\n10. Debug it\n\n\nSML\n provides logging capabilities in order to inspect state machine flow.\nTo enable logging you can use (Logger Policy)(user_guide.md#policies)\n\n\nstruct my_logger {\n  template \nclass SM, class TEvent\n\n  void log_process_event(const TEvent\n) {\n    printf(\n[%s][process_event] %s\\n\n, typeid(SM).name(), typeid(TEvent).name());\n  }\n\n  template \nclass SM, class TGuard, class TEvent\n\n  void log_guard(const TGuard\n, const TEvent\n, bool result) {\n    printf(\n[%s][guard] %s %s %s\\n\n, typeid(SM).name(), typeid(TGuard).name(), typeid(TEvent).name(),\n           (result ? \n[OK]\n : \n[Reject]\n));\n  }\n\n  template \nclass SM, class TAction, class TEvent\n\n  void log_action(const TAction\n, const TEvent\n) {\n    printf(\n[%s][action] %s %s\\n\n, typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());\n  }\n\n  template \nclass SM, class TSrcState, class TDstState\n\n  void log_state_change(const TSrcState\n src, const TDstState\n dst) {\n    printf(\n[%s][transition] %s -\n %s\\n\n, typeid(SM).name(), src.c_str(), dst.c_str());\n  }\n};\n\nsml::sm\nlogging, sml::logger\nmy_logger\n sm;\nsm.process_event(my_event{}); // will call my_logger appropriately\n\n\n\n\n\n\n Logging Example\n\n\n Plant UML Example", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/index.html#0-read-boostmsm-euml-documentation", 
            "text": "Boost.MSM - UML Short Guide  Boost.MSM - eUML Documentation", 
            "title": "0. Read Boost.MSM - eUML documentation"
        }, 
        {
            "location": "/tutorial/index.html#1-create-events-and-states", 
            "text": "State machine is composed of finite number of states and transitions which are triggered via events.  An Event is just a unique type, which will be processed by the state machine.  struct my_event { ... };  You can also create event instance in order to simplify transition table notation.  auto event = sml::event my_event ;  If you happen to have a Clang/GCC compiler, you can create an Event on the fly.  using namespace sml;\nauto event  =  event _t;  However, such event will not store any data.  A State can have entry/exit behaviour executed whenever machine enters/leaves State and\nrepresents current location of the state machine flow.  To create a state below snippet might be used.  auto idle = sml::state class idle ;  If you happen to have a Clang/GCC compiler, you can create a State on the fly.  using namespace sml;\nauto state  =  idle _s;  However, please notice that above solution is a non-standard extension for Clang/GCC.  SML  states cannot have data as data is injected directly into guards/actions instead.  A state machine might be a State itself.  sml::state state_machine  composite;  SML  supports  terminate  state, which stops events to be processed. It defined by  X .  state _s = X;  States are printable too.  assert(string( idle ) ==  idle _s.c_str());    Events Example   States Example   Composite Example", 
            "title": "1. Create events and states"
        }, 
        {
            "location": "/tutorial/index.html#2-create-guards-and-actions", 
            "text": "Guards and actions are callable objects which will be executed by the state machine in order to verify whether a transition, followed by an action should take place.  Guard MUST return boolean value.  auto guard1 = [] {\n  return true;\n};\n\nauto guard2 = [](int, double) { // guard with dependencies\n  return true;\n};\n\nauto guard3 = [](int, auto event, double) { // guard with an event and dependencies\n  return true;\n};\n\nstruct guard4 {\n    bool operator()() const noexcept {\n        return true;\n    }\n};  Action MUST not return.  auto action1 = [] { };\nauto action2 = [](int, double) { }; // action with dependencies\nauto action3 = [](int, auto event, double) { }; // action with an event and dependencies\nstruct action4 {\n    void operator()() noexcept { }\n};    Actions Guards Example", 
            "title": "2. Create guards and actions"
        }, 
        {
            "location": "/tutorial/index.html#3-create-a-transition-table", 
            "text": "When we have states and events handy we can finally create a transition table which represents\nour transitions.  SML  is using eUML-like DSL in order to be as close as possible to UML design.    Transition Table DSL   Postfix Notation      Expression  Description      state + event  [ guard ]  internal transition on event e when guard    src_state / [] {} = dst_state  anonymous transition with action    src_state / [] {} = src_state  self transition (calls on_exit/on_entry)    src_state + event  = dst_state  external transition on event e without guard or action    src_state + event  [ guard ] / action = dst_state  transition from src_state to dst_state on event e with guard and action    src_state + event  [ guard   (![]{return true;}   guard2) ] / (action, action2, []{}) = dst_state  transition from src_state to dst_state on event e with guard and action      Prefix Notation      Expression  Description      state + event  [ guard ]  internal transition on event e when guard    dst_state  = src_state / [] {}  anonymous transition with action    src_state  = src_state / [] {}  self transition (calls on_exit/on_entry)    dst_state  = src_state + event  external transition on event e without guard or action    dst_state  = src_state + event  [ guard ] / action  transition from src_state to dst_state on event e with guard and action    dst_state  = src_state + event  [ guard   (![]{return true;}   guard2) ] / (action, action2, []{})  transition from src_state to dst_state on event e with guard and action       Transition flow    src_state + event [ guard ] / action = dst_state\n                                     ^\n                                     |\n                                     |\n                                    1. src_state + on_exit\n                                    2. dst_state + on_entry  To create a transition table  make_transition_table  is provided.  using namespace sml; // Postfix Notation\n\nmake_transition_table(\n * src_state _s + event my_event  [ guard ] / action =  dst_state _s\n,  dst_state _s +  other_event _t = X\n);  or  using namespace sml; // Prefix Notation\n\nmake_transition_table(\n   dst_state _s  = * src_state _s + event my_event  [ guard ] / action\n, X              =  dst_state _s  +  other_event _t\n);    Transition Table Example   eUML Emulation Example", 
            "title": "3. Create a transition table"
        }, 
        {
            "location": "/tutorial/index.html#4-set-initial-states", 
            "text": "Initial state tells the state machine where to start. It can be set by prefixing a State with  * .  using namespace sml;\nmake_transition_table(\n * src_state _s + event my_event  [ guard ] / action =  dst_state _s,\n   dst_state _s + event game_over  = X\n);  Initial/Current state might be remembered by the State Machine so that whenever it will reentered\nthe last active state will reactivated. In order to enable history you just have\nto replace  *  with postfixed  (H)  when declaring the initial state.  using namespace sml;\nmake_transition_table(\n   src_state _s(H) + event my_event  [ guard ] / action =  dst_state _s,\n   dst_state _s    + event game_over                    = X\n);  You can have more than one initial state. All initial states will be executed in pseudo-parallel way\n. Such states are called  Orthogonal regions .  using namespace sml;\nmake_transition_table(\n * region_1 _s   + event my_event1  [ guard ] / action =  dst_state1 _s,\n   dst_state1 _s + event game_over  = X,\n\n * region_2 _s   + event my_event2  [ guard ] / action =  dst_state2 _s,\n   dst_state2 _s + event game_over  = X\n);    Orthogonal Regions Example   History Example", 
            "title": "4. Set initial states"
        }, 
        {
            "location": "/tutorial/index.html#5-create-a-state-machine", 
            "text": "State machine is an abstraction for transition table holding current states and processing events.\nTo create a state machine, we have to add a transition table.  class example {\npublic:\n  auto opeartor()() {\n    using namespace sml;\n    return make_transition_table(\n     * src_state _s + event my_event  [ guard ] / action =  dst_state _s,\n       dst_state _s + event game_over  = X\n    );\n  }\n};  Having transition table configured we can create a state machine.  sml::sm example  sm;  State machine constructor provides required dependencies for actions and guards.                              /---- event (injected from process_event)\n                            |\nauto guard = [](double d, auto event) { return true; }\n                   |\n                   \\-------\\\n                           |\nauto action = [](int i){}  |\n                 |         |\n                 |         |\n                 \\-\\   /---/\n                   |   |\nsml::sm exmple  s{42, 87.0};\n\nsml::sm exmple  s{87.0, 42}; // order in which parameters have to passed is not specificied  Passing and maintaining a lot of dependencies might be tedious and requires huge amount of boilerplate code.\nIn order to avoid it, Dependency Injection Library might be used to automate this process.\nFor example, we can use  Experimental Boost.DI .  auto injector = di::make_injector(\n    di::bind .to(42)\n  , di::bind interface .to implementation ()\n);\n\nauto sm = injector.create sm example ();\nsm.process_event(e1{});    Hello World Example   Dependency Injection Example", 
            "title": "5. Create a state machine"
        }, 
        {
            "location": "/tutorial/index.html#6-process-events", 
            "text": "State machine is a simple creature. Its main purpose is to process events.\nIn order to do it,  process_event  method might be used.  sml::sm example  sm;\n\nsm.process_event(my_event{}); // handled\nsm.process_event(int{}); // not handled -  unexpected_event int   Process event might be also triggered on transition table.  using namespace sml;\nreturn make_transition_table(\n * s1 _s + event my_event  / process_event(other_event{}) =  s2 _s,\n   s2 _s + event other_event  = X\n);  SML  also provides a way to dispatch dynamically created events into the state machine.  struct game_over {\n  static constexpr auto id = SDL_QUIT;\n  // explicit game_over(const SDL_Event ) noexcept; // optional, when defined runtime event will be passed\n};\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\n//create dispatcher from state machine and range of events\nauto dispatch_event = sml::utility::make_dispatch_table SDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT (sm);\nSDL_Event event{SDL_QUIT};\ndispatch_event(event, event.type); // will call sm.process(game_over{});    Hello World Example   Dispatch Table Example   SDL2 Integration Example", 
            "title": "6. Process events"
        }, 
        {
            "location": "/tutorial/index.html#8-handle-errors", 
            "text": "In case when a State Machine can't handle given event an  unexpected_event  is fired.  make_transition_table(\n * src_state _s + event my_event  [ guard ] / action =  dst_state _s\n,  src_state _s + unexpected_event some_event  = X\n);  Any unexpected event might be handled too by using  unexpected_event .  make_transition_table(\n * src_state _s + event my_event  [ guard ] / action =  dst_state _s\n,  src_state _s + unexpected_event some_event  / [] { std::cout    unexpected 'some_event'   '\\n';  }\n,  src_state _s + unexpected_event  = X // any event\n);  In such case...  sm.process_event(some_event{}); // \"unexpected 'some_event'\nsm.process_event(int{}); // terminate\nassert(sm.is(X));  \nUsually, it's handy to create additional `Orthogonal region` to cover this scenario,\nThis way State causing unexpected event does not matter.\n\n```cpp\nmake_transition_table(\n * idle _s + event my_event  [ guard ] / action =  s1 _s\n,  s1 _s + event other_event  [ guard ] / action =  s2 _s\n,  s2 _s + event yet_another_event  [ guard ] / action = X\n// terminate (=X) the Machine or reset to another state\n,* error_handler _s + unexpected_event some_event  = X\n);  We can always check whether a State Machine is in terminate state by.  assert(sm.is(sml::X)); // doesn't matter how many regions there are  When exceptions are enabled (project is NOT compiled with  -fno-exceptions ) they\ncan be caught using  exception name  syntax. Exception handlers will be processed\nin the order they were defined, and  exception  might be used to catch anything (equivalent to  catch (...) ).\nPlease, notice that when there is no exception handler defined in the Transition Table, exception will not be handled by the State Machine.  make_transition_table(\n * idle _s + event event  / [] { throw std::runtime_error{ error }; }\n,* error_handler _s + exception std::runtime_error  = X\n,  error_handler _s + exception std::logic_error  = X\n,  error_handler _s + exception  / [] { cleanup...; } = X // any exception\n);    Error Handling Example", 
            "title": "8. Handle errors"
        }, 
        {
            "location": "/tutorial/index.html#9-test-it", 
            "text": "Sometimes it's useful to verify whether a state machine is in a specific state, for example, if\nwe are in a terminate state or not. We can do it with  SML  using  is  or  visit_current_states \nfunctionality.  sml::sm example  sm;\nsm.process_event(my_event{});\nassert(sm.is(X)); // is(X, s1, ...) when you have orthogonal regions\n\n//or\n\nsm.visit_current_states([](auto state) { std::cout   state.c_str()   std::endl; });  On top of that,  SML  provides testing facilities to check state machine as a whole. set_current_states  method is available from  testing::sm  in order to set state machine\nin a requested state.  testing::sm example  sm{fake_data...};\nsm.set_current_states( s3 _s); // set_current_states( s3 _s,  s1 _s, ...) for orthogonal regions\nsm.process_event(event{});\nassert(sm.is(X));    Testing Example", 
            "title": "9. Test it"
        }, 
        {
            "location": "/tutorial/index.html#10-debug-it", 
            "text": "SML  provides logging capabilities in order to inspect state machine flow.\nTo enable logging you can use (Logger Policy)(user_guide.md#policies)  struct my_logger {\n  template  class SM, class TEvent \n  void log_process_event(const TEvent ) {\n    printf( [%s][process_event] %s\\n , typeid(SM).name(), typeid(TEvent).name());\n  }\n\n  template  class SM, class TGuard, class TEvent \n  void log_guard(const TGuard , const TEvent , bool result) {\n    printf( [%s][guard] %s %s %s\\n , typeid(SM).name(), typeid(TGuard).name(), typeid(TEvent).name(),\n           (result ?  [OK]  :  [Reject] ));\n  }\n\n  template  class SM, class TAction, class TEvent \n  void log_action(const TAction , const TEvent ) {\n    printf( [%s][action] %s %s\\n , typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());\n  }\n\n  template  class SM, class TSrcState, class TDstState \n  void log_state_change(const TSrcState  src, const TDstState  dst) {\n    printf( [%s][transition] %s -  %s\\n , typeid(SM).name(), src.c_str(), dst.c_str());\n  }\n};\n\nsml::sm logging, sml::logger my_logger  sm;\nsm.process_event(my_event{}); // will call my_logger appropriately    Logging Example   Plant UML Example", 
            "title": "10. Debug it"
        }, 
        {
            "location": "/uml_vs_sml/index.html", 
            "text": "Unified Modeling Language\u2122 (UML\u00ae) Version 2.5\n\n\n\n\nhttp://www.omg.org/spec/UML/2.5\n\n\n\n\n\n\nInitial Pseudostate\n\n\nUML \n\n\nSML\n\n\n*(\nidle\n)\n\n\n\n\n\n\nTerminate Pseudostate\n\n\nUML \n\n\nSML\n\n\nX\n\n\n\n\n\n\nExternal transition\n\n\nUML \n\n\nSML\n\n\nsrc_state\n_s + event [ guard ] / action = \ndst_state\n_s\n\n\n\n\n\n\nwhere\n\n\n\n\nstruct event {};\nconst auto guard = [] { return true; };\nconst auto action = [] {};\n\n\n\n\n\n\nAnonymous transition\n\n\nUML \n\n\nSML\n\n\nidle [ guard ] / action = connecting\n\n\n\n\n\n\nInternal transition\n\n\n\n\nEntry/Exit action\n\n\n\n\nSelf transition\n\n\n\n\nSub/Composite\n\n\n\n\nOrthogonal regions\n\n\n\n\nDeep History\n\n\n\n\nShallow History\n\n\n\n\nEvent defering", 
            "title": "UML vs SML"
        }, 
        {
            "location": "/uml_vs_sml/index.html#unified-modeling-languagetm-uml-version-25", 
            "text": "http://www.omg.org/spec/UML/2.5", 
            "title": "Unified Modeling Language\u2122 (UML\u00ae) Version 2.5"
        }, 
        {
            "location": "/uml_vs_sml/index.html#initial-pseudostate", 
            "text": "UML   SML  *( idle )", 
            "title": "Initial Pseudostate"
        }, 
        {
            "location": "/uml_vs_sml/index.html#terminate-pseudostate", 
            "text": "UML   SML  X", 
            "title": "Terminate Pseudostate"
        }, 
        {
            "location": "/uml_vs_sml/index.html#external-transition", 
            "text": "UML   SML  src_state _s + event [ guard ] / action =  dst_state _s   where   struct event {};\nconst auto guard = [] { return true; };\nconst auto action = [] {};", 
            "title": "External transition"
        }, 
        {
            "location": "/uml_vs_sml/index.html#anonymous-transition", 
            "text": "UML   SML  idle [ guard ] / action = connecting", 
            "title": "Anonymous transition"
        }, 
        {
            "location": "/uml_vs_sml/index.html#internal-transition", 
            "text": "", 
            "title": "Internal transition"
        }, 
        {
            "location": "/uml_vs_sml/index.html#entryexit-action", 
            "text": "", 
            "title": "Entry/Exit action"
        }, 
        {
            "location": "/uml_vs_sml/index.html#self-transition", 
            "text": "", 
            "title": "Self transition"
        }, 
        {
            "location": "/uml_vs_sml/index.html#subcomposite", 
            "text": "", 
            "title": "Sub/Composite"
        }, 
        {
            "location": "/uml_vs_sml/index.html#orthogonal-regions", 
            "text": "", 
            "title": "Orthogonal regions"
        }, 
        {
            "location": "/uml_vs_sml/index.html#deep-history", 
            "text": "", 
            "title": "Deep History"
        }, 
        {
            "location": "/uml_vs_sml/index.html#shallow-history", 
            "text": "", 
            "title": "Shallow History"
        }, 
        {
            "location": "/uml_vs_sml/index.html#event-defering", 
            "text": "", 
            "title": "Event defering"
        }, 
        {
            "location": "/user_guide/index.html", 
            "text": "transitional [concept]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nRequirements for transition.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool transitional() {\n  return requires(T transition) {\n    typename T::src_state;\n    typename T::dst_state;\n    typename T::event;\n    typename T::deps;\n    T::initial;\n    T::history;\n    { transition.execute() } -\n bool;\n  }\n};\n\n\n\nSemantics\n\n\ntransitional\nT\n\n\n\n\nExample\n\n\nusing namespace sml;\n\n{\nauto transition = (\"idle\"_s = X); // Postfix Notation\nstatic_assert(transitional\ndecltype(transition)\n::value);\n}\n\n{\nauto transition = (X \n= \"idle\"_s); // Prefix Notation\nstatic_assert(transitional\ndecltype(transition)\n::value);\n}\n\n\n\n\n\n Transitional Example\n\n\n\n\n\n\n\n\nconfigurable [concept]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nRequirements for the state machine.\n\n\nSynopsis\n\n\ntemplate \nclass SM\n\nconcept bool configurable() {\n  return requires(SM sm) {\n    { sm.operator()() };\n  }\n};\n\n\n\nSemantics\n\n\nconfigurable\nSM\n\n\n\n\nExample\n\n\nclass example {\n  auto operator()() const noexcept {\n    return make_transition_table();\n  }\n};\n\nstatic_assert(configurable\nexample\n::value);\n\n\n\n\n\n Configurable Example\n\n\n\n\n\n\n\n\ncallable [concept]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nRequirements for action and guards.\n\n\nSynopsis\n\n\ntemplate \nclass TResult, class T\n\nconcept bool callable() {\n  return requires(T object) {\n    { object(...) } -\n TResult;\n  }\n}\n\n\n\nSemantics\n\n\ncallable\nSM\n\n\n\n\nExample\n\n\nauto guard = [] { return true; };\nauto action = [] { };\n\nstatic_assert(callable\nbool, decltype(guard)\n::value);\nstatic_assert(callable\nvoid, decltype(action)\n::value);\n\n\n\n\n\n Callable Example\n\n\n\n\n\n\n\n\ndispatchable [concept]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nRequirements for the dispatch table.\n\n\nSynopsis\n\n\ntemplate \nclass TDynamicEvent, TEvent\n\nconcept bool dispatchable() {\n  return requires(T) {\n    typename TEvent::id;\n    { TEvent(declval\nTDynamicEvent\n()) };\n  }\n};\n\n\n\nSemantics\n\n\ndispatchable\nSM\n\n\n\n\nExample\n\n\nstruct runtime_event { };\n\nstruct event1 {\n  static constexpr auto id = 1;\n};\n\nstruct event2 {\n  static constexpr auto id = 2;\n  explicit event2(const runtime_event\n) {}\n};\n\nstatic_assert(dispatchable\nruntime_event, event1\n::value);\nstatic_assert(dispatchable\nruntime_event, event2\n::value);\n\n\n\n\n\n Dispatchable Example\n\n\n SDL2 Integration Example\n\n\n\n\n\n\n\n\nstate [core]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nRepresents a state machine state.\n\n\nSynopsis\n\n\ntemplate\nclass TState\n // no requirements, TState may be a state machine\nclass state {\npublic:\n  initial operator*() const noexcept; // no requirements\n\n  template \nclass T\n // no requirements\n  auto operator\n=(const T \n) const noexcept;\n\n  template \nclass T\n // no requirements\n  auto operator=(const T \n) const noexcept;\n\n  template \nclass T\n // no requirements\n  auto operator+(const T \n) const noexcept;\n\n  template \nclass T\n requires callable\nbool, T\n\n  auto operator[](const T) const noexcept;\n\n  template \nclass T\n requires callable\nvoid, T\n\n  auto operator/(const T \nt) const noexcept;\n\n  const char* c_str() noexcept;\n};\n\ntemplate \nclass T, T... Chrs\n\nstate\nunspecified\n operator\"\"_s() noexcept;\n\n// predefined states\nstate\nunspecified\n X;\n\n\n\nRequirements\n\n\n\n\ncallable\n\n\n\n\nSemantics\n\n\nstate\nT\n{}\n\n\n\nExample\n\n\nauto idle = state\nclass idle\n;\nauto idle = \"idle\"_s;\n\nauto initial_state = *idle;\nauto history_state = idle(H);\nauto terminate_state = X;\n\n\n\n\n\n States Example\n\n\n Composite Example\n\n\n Orthogonal Regions Example\n\n\n\n\n\n\n\n\nevent [core]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nRepresents a state machine event.\n\n\nSynopsis\n\n\ntemplate\nTEvent\n // no requirements\nclass event {\npublic:\n  template \nclass T\n requires callable\nbool, T\n\n  auto operator[](const T \n) const noexcept;\n\n  template \nclass T\n requires callable\nvoid, T\n\n  auto operator/(const T \nt) const noexcept;\n};\n\ntemplate\nclass TEvent\n\nevent\nTEvent\n event{};\n\n// predefined events\nauto on_entry = event\nunspecified\n;\nauto on_exit = event\nunspecified\n;\n\ntemplate\nclass TEvent\n unexpected_event{};\ntemplate\nclass T\n exception{};\n\n\n\nRequirements\n\n\n\n\ncallable\n\n\n\n\nSemantics\n\n\nevent\nT\n\n\n\n\nExample\n\n\nauto my_int_event = event\nint\n;\n\n\n\n\n\n Events Example\n\n\n Error Handling Example\n\n\n\n\n\n\n\n\nmake_transition_table [state machine]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nCreates a transition table.\n\n\nSynopsis\n\n\ntemplate \nclass... Ts\n requires transitional\nTs\n...\nauto make_transition_table(Ts...) noexcept;\n\n\n\nRequirements\n\n\n\n\ntransitional\n\n\n\n\nSemantics\n\n\nmake_transition_table(transitions...);\n\n\n\nExample\n\n\nauto transition_table_postfix_notation = make_transition_table(\n  *\"idle_s\" + event\nint\n / [] {} = X\n);\n\nauto transition_table_prefix_notation = make_transition_table(\n  X \n= *\"idle_s\" + event\nint\n / [] {}\n);\n\nclass example {\npublic:\n  auto operator()() const noexcept {\n    return make_transition_table();\n  }\n};\n\n\n\n\n\n Transition Table Example\n\n\n\n\n\n\n\n\nsm [state machine]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nCreates a State Machine.\n\n\nSynopsis\n\n\ntemplate\nclass T\n requires configurable\nT\n\nclass sm {\npublic:\n  using states = unspecified; // unique list of states\n  using events = unspecified; // unique list of events which can be handled by the State Machine\n  using transitions = unspecified; // list of transitions\n\n  sm(sm \n) = default;\n  sm(const sm \n) = delete;\n  sm \noperator=(const sm \n) = delete;\n\n  template \nclass... TDeps\n requires is_base_of\nTDeps, dependencies\n...\n  sm(TDeps\n...) noexcept;\n\n  template\nclass TEvent\n // no requirements\n  bool process_event(const TEvent\n)\n\n  template \nclass TVisitor\n requires callable\nvoid, TVisitor\n\n  void visit_current_states(const TVisitor \n) const noexcept(noexcept(visitor(state{})));\n\n  template \nclass TState\n\n  bool is(const state\nTState\n \n) const noexcept;\n\n  template \nclass... TStates\n requires sizeof...(TStates) == number_of_initial_states\n  bool is(const state\nTStates\n \n...) const noexcept;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTDeps...\n\n\nis_base_of dependencies\n\n\nconstructor\n\n\n\n\n\n\n\n\nprocess_event\nTEvent\n\n\n-\n\n\nprocess event \nTEvent\n\n\nreturns true when handled, false otherwise\n\n\n\n\n\n\nvisit_current_states\nTVisitor\n\n\ncallable\n\n\nvisit current states\n\n\n-\n\n\n\n\n\n\nis\nTState\n\n\n-\n\n\nverify whether any of current states equals \nTState\n\n\ntrue when any current state matches \nTState\n, false otherwise\n\n\n\n\n\n\nis\nTStates...\n\n\nsize of TStates... equals number of initial states\n\n\nverify whether all current states match \nTStates...\n\n\ntrue when all states match \nTState...\n, false otherwise\n\n\n\n\n\n\n\n\nSemantics\n\n\nsml::sm\nT\n{...};\nsm.process_event(TEvent{});\nsm.visit_current_states([](auto state){});\nsm.is(X);\nsm.is(s1, s2);\n\n\n\nExample\n\n\nstruct my_event {};\n\nclass example {\npublic:\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n      *\"idle\"_s + event\nmy_event\n / [](int i) { std::cout \n i \n std::endl; } = X\n    );\n  }\n};\n\nsml::sm\nexample\n sm{42};\nassert(sm.is(\"idle\"_s));\nsm.process_event(int{}); // no handled, will call unexpected_event\nint\n\nsm.process_event(my_event{}); // handled\nassert(sm.is(X));\n\nsm.visit_current_states([](auto state) { std::cout \n state.c_str() \n std::endl; });\n\n\n\n\n\n Hello World Example\n\n\n Dependency Injection Example\n\n\n eUML Emulation Example\n\n\n\n\n\n\n\n\npolicies [state machine]\n\n\nHeader\n\n\n#include \nboost/sml.hpp\n\n\n\n\nDescription\n\n\nAdditional State Machine configurations.\n\n\nSynopsis\n\n\nthread_safe\nLockable\n\nlogger\nLoggable\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nLockable\n\n\nlock/unlock\n\n\nLockable type\n\n\nstd::mutex\n, \nstd::recursive_mutex\n\n\n\n\n\n\nLoggable\n\n\nlog_process_event/log_state_change/log_action/log_guard\n\n\nLoggable type\n\n\n-\n\n\n\n\n\n\n\n\nExample\n\n\nsml::sm\nexample, sml::thread_safe\nstd::recursive_mutex\n sm; // thread safe policy\nsml::sm\nexample, sml::logger\nmy_logger\n sm; // logger policy\nsml::sm\nexample, sml::thread_safe\nstd::recursive_mutex\n, sml::logger\nmy_logger\n sm; // thread safe and logger policy\nsml::sm\nexample, sml::logger\nmy_logger\n, sml::thread_safe\nstd::recursive_mutex\n sm; // thread safe and logger policy\n\n\n\n\n\n Logging Example\n\n\n\n\n\n\n\n\ntesting::sm [testing]\n\n\nHeader\n\n\n#include \nboost/sml/testing/state_machine.hpp\n\n\n\n\nDescription\n\n\nCreates a state machine with testing capabilities.\n\n\nSynopsis\n\n\nnamespace testing {\n  template \nclass T\n\n  class sm : public sml::sm\nT\n {\n   public:\n    using sml::sm\nT\n::sm;\n\n    template \nclass... TStates\n\n    void set_current_states(const detail::state\nTStates\n \n...) noexcept;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nset_current_states\nTStates...\n\n\n-\n\n\nset current states\n\n\n\n\n\n\n\n\n\n\nSemantics\n\n\nsml::testing::sm\nT\n{...};\nsm.set_current_states(\"s1\"_s);\n\n\n\nExample\n\n\nsml::testing::sm\nT\n{inject_fake_data...};\nsm.set_current_states(\"s1\"_s);\nsm.process_event(TEvent{});\nsm.is(X);\n\n\n\n\n\n Testing Example\n\n\n\n\n\n\n\n\nmake_dispatch_table [utility]\n\n\nHeader\n\n\n#include \nboost/sml/utility/dispatch_table.hpp\n\n\n\n\nDescription\n\n\nCreates a dispatch table to handle runtime events.\n\n\nSynopsis\n\n\nnamespace utility {\n  template\nclass TEvent, int EventRangeBegin, int EventRangeBegin, class SM\n requires dispatchable\nTEvent, typename SM::events\n\n  callable\nbool, (TEvent, int)\n make_dispatch_table(sm\nSM\n) noexcept;\n}\n\n\n\nRequirements\n\n\n\n\ndispatchable\n\n\n\n\nSemantics\n\n\nsml::utility::make_dispatch_table\nT, 0, 10\n(sm);\n\n\n\nExample\n\n\nstruct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event \n) {}\n};\n\nauto dispatch_event = sml::utility::make_dispatch_table\nruntime_event, 1 /*min*/, 5 /*max*/\n(sm);\ndispatch_event(event, event.id);\n\n\n\n\n\n Dispatch Table Example\n\n\n SDL2 Integration Example", 
            "title": "User Guide"
        }, 
        {
            "location": "/user_guide/index.html#transitional-concept", 
            "text": "Header  #include  boost/sml.hpp   Description  Requirements for transition.  Synopsis  template  class T \nconcept bool transitional() {\n  return requires(T transition) {\n    typename T::src_state;\n    typename T::dst_state;\n    typename T::event;\n    typename T::deps;\n    T::initial;\n    T::history;\n    { transition.execute() } -  bool;\n  }\n};  Semantics  transitional T   Example  using namespace sml;\n\n{\nauto transition = (\"idle\"_s = X); // Postfix Notation\nstatic_assert(transitional decltype(transition) ::value);\n}\n\n{\nauto transition = (X  = \"idle\"_s); // Prefix Notation\nstatic_assert(transitional decltype(transition) ::value);\n}    Transitional Example", 
            "title": "transitional [concept]"
        }, 
        {
            "location": "/user_guide/index.html#configurable-concept", 
            "text": "Header  #include  boost/sml.hpp   Description  Requirements for the state machine.  Synopsis  template  class SM \nconcept bool configurable() {\n  return requires(SM sm) {\n    { sm.operator()() };\n  }\n};  Semantics  configurable SM   Example  class example {\n  auto operator()() const noexcept {\n    return make_transition_table();\n  }\n};\n\nstatic_assert(configurable example ::value);    Configurable Example", 
            "title": "configurable [concept]"
        }, 
        {
            "location": "/user_guide/index.html#callable-concept", 
            "text": "Header  #include  boost/sml.hpp   Description  Requirements for action and guards.  Synopsis  template  class TResult, class T \nconcept bool callable() {\n  return requires(T object) {\n    { object(...) } -  TResult;\n  }\n}  Semantics  callable SM   Example  auto guard = [] { return true; };\nauto action = [] { };\n\nstatic_assert(callable bool, decltype(guard) ::value);\nstatic_assert(callable void, decltype(action) ::value);    Callable Example", 
            "title": "callable [concept]"
        }, 
        {
            "location": "/user_guide/index.html#dispatchable-concept", 
            "text": "Header  #include  boost/sml.hpp   Description  Requirements for the dispatch table.  Synopsis  template  class TDynamicEvent, TEvent \nconcept bool dispatchable() {\n  return requires(T) {\n    typename TEvent::id;\n    { TEvent(declval TDynamicEvent ()) };\n  }\n};  Semantics  dispatchable SM   Example  struct runtime_event { };\n\nstruct event1 {\n  static constexpr auto id = 1;\n};\n\nstruct event2 {\n  static constexpr auto id = 2;\n  explicit event2(const runtime_event ) {}\n};\n\nstatic_assert(dispatchable runtime_event, event1 ::value);\nstatic_assert(dispatchable runtime_event, event2 ::value);    Dispatchable Example   SDL2 Integration Example", 
            "title": "dispatchable [concept]"
        }, 
        {
            "location": "/user_guide/index.html#state-core", 
            "text": "Header  #include  boost/sml.hpp   Description  Represents a state machine state.  Synopsis  template class TState  // no requirements, TState may be a state machine\nclass state {\npublic:\n  initial operator*() const noexcept; // no requirements\n\n  template  class T  // no requirements\n  auto operator =(const T  ) const noexcept;\n\n  template  class T  // no requirements\n  auto operator=(const T  ) const noexcept;\n\n  template  class T  // no requirements\n  auto operator+(const T  ) const noexcept;\n\n  template  class T  requires callable bool, T \n  auto operator[](const T) const noexcept;\n\n  template  class T  requires callable void, T \n  auto operator/(const T  t) const noexcept;\n\n  const char* c_str() noexcept;\n};\n\ntemplate  class T, T... Chrs \nstate unspecified  operator\"\"_s() noexcept;\n\n// predefined states\nstate unspecified  X;  Requirements   callable   Semantics  state T {}  Example  auto idle = state class idle ;\nauto idle = \"idle\"_s;\n\nauto initial_state = *idle;\nauto history_state = idle(H);\nauto terminate_state = X;    States Example   Composite Example   Orthogonal Regions Example", 
            "title": "state [core]"
        }, 
        {
            "location": "/user_guide/index.html#event-core", 
            "text": "Header  #include  boost/sml.hpp   Description  Represents a state machine event.  Synopsis  template TEvent  // no requirements\nclass event {\npublic:\n  template  class T  requires callable bool, T \n  auto operator[](const T  ) const noexcept;\n\n  template  class T  requires callable void, T \n  auto operator/(const T  t) const noexcept;\n};\n\ntemplate class TEvent \nevent TEvent  event{};\n\n// predefined events\nauto on_entry = event unspecified ;\nauto on_exit = event unspecified ;\n\ntemplate class TEvent  unexpected_event{};\ntemplate class T  exception{};  Requirements   callable   Semantics  event T   Example  auto my_int_event = event int ;    Events Example   Error Handling Example", 
            "title": "event [core]"
        }, 
        {
            "location": "/user_guide/index.html#make_transition_table-state-machine", 
            "text": "Header  #include  boost/sml.hpp   Description  Creates a transition table.  Synopsis  template  class... Ts  requires transitional Ts ...\nauto make_transition_table(Ts...) noexcept;  Requirements   transitional   Semantics  make_transition_table(transitions...);  Example  auto transition_table_postfix_notation = make_transition_table(\n  *\"idle_s\" + event int  / [] {} = X\n);\n\nauto transition_table_prefix_notation = make_transition_table(\n  X  = *\"idle_s\" + event int  / [] {}\n);\n\nclass example {\npublic:\n  auto operator()() const noexcept {\n    return make_transition_table();\n  }\n};    Transition Table Example", 
            "title": "make_transition_table [state machine]"
        }, 
        {
            "location": "/user_guide/index.html#sm-state-machine", 
            "text": "Header  #include  boost/sml.hpp   Description  Creates a State Machine.  Synopsis  template class T  requires configurable T \nclass sm {\npublic:\n  using states = unspecified; // unique list of states\n  using events = unspecified; // unique list of events which can be handled by the State Machine\n  using transitions = unspecified; // list of transitions\n\n  sm(sm  ) = default;\n  sm(const sm  ) = delete;\n  sm  operator=(const sm  ) = delete;\n\n  template  class... TDeps  requires is_base_of TDeps, dependencies ...\n  sm(TDeps ...) noexcept;\n\n  template class TEvent  // no requirements\n  bool process_event(const TEvent )\n\n  template  class TVisitor  requires callable void, TVisitor \n  void visit_current_states(const TVisitor  ) const noexcept(noexcept(visitor(state{})));\n\n  template  class TState \n  bool is(const state TState   ) const noexcept;\n\n  template  class... TStates  requires sizeof...(TStates) == number_of_initial_states\n  bool is(const state TStates   ...) const noexcept;\n};     Expression  Requirement  Description  Returns      TDeps...  is_base_of dependencies  constructor     process_event TEvent  -  process event  TEvent  returns true when handled, false otherwise    visit_current_states TVisitor  callable  visit current states  -    is TState  -  verify whether any of current states equals  TState  true when any current state matches  TState , false otherwise    is TStates...  size of TStates... equals number of initial states  verify whether all current states match  TStates...  true when all states match  TState... , false otherwise     Semantics  sml::sm T {...};\nsm.process_event(TEvent{});\nsm.visit_current_states([](auto state){});\nsm.is(X);\nsm.is(s1, s2);  Example  struct my_event {};\n\nclass example {\npublic:\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n      *\"idle\"_s + event my_event  / [](int i) { std::cout   i   std::endl; } = X\n    );\n  }\n};\n\nsml::sm example  sm{42};\nassert(sm.is(\"idle\"_s));\nsm.process_event(int{}); // no handled, will call unexpected_event int \nsm.process_event(my_event{}); // handled\nassert(sm.is(X));\n\nsm.visit_current_states([](auto state) { std::cout   state.c_str()   std::endl; });    Hello World Example   Dependency Injection Example   eUML Emulation Example", 
            "title": "sm [state machine]"
        }, 
        {
            "location": "/user_guide/index.html#policies-state-machine", 
            "text": "Header  #include  boost/sml.hpp   Description  Additional State Machine configurations.  Synopsis  thread_safe Lockable \nlogger Loggable      Expression  Requirement  Description  Example      Lockable  lock/unlock  Lockable type  std::mutex ,  std::recursive_mutex    Loggable  log_process_event/log_state_change/log_action/log_guard  Loggable type  -     Example  sml::sm example, sml::thread_safe std::recursive_mutex  sm; // thread safe policy\nsml::sm example, sml::logger my_logger  sm; // logger policy\nsml::sm example, sml::thread_safe std::recursive_mutex , sml::logger my_logger  sm; // thread safe and logger policy\nsml::sm example, sml::logger my_logger , sml::thread_safe std::recursive_mutex  sm; // thread safe and logger policy    Logging Example", 
            "title": "policies [state machine]"
        }, 
        {
            "location": "/user_guide/index.html#testingsm-testing", 
            "text": "Header  #include  boost/sml/testing/state_machine.hpp   Description  Creates a state machine with testing capabilities.  Synopsis  namespace testing {\n  template  class T \n  class sm : public sml::sm T  {\n   public:\n    using sml::sm T ::sm;\n\n    template  class... TStates \n    void set_current_states(const detail::state TStates   ...) noexcept;\n  };\n}     Expression  Requirement  Description  Returns      set_current_states TStates...  -  set current states      Semantics  sml::testing::sm T {...};\nsm.set_current_states(\"s1\"_s);  Example  sml::testing::sm T {inject_fake_data...};\nsm.set_current_states(\"s1\"_s);\nsm.process_event(TEvent{});\nsm.is(X);    Testing Example", 
            "title": "testing::sm [testing]"
        }, 
        {
            "location": "/user_guide/index.html#make_dispatch_table-utility", 
            "text": "Header  #include  boost/sml/utility/dispatch_table.hpp   Description  Creates a dispatch table to handle runtime events.  Synopsis  namespace utility {\n  template class TEvent, int EventRangeBegin, int EventRangeBegin, class SM  requires dispatchable TEvent, typename SM::events \n  callable bool, (TEvent, int)  make_dispatch_table(sm SM ) noexcept;\n}  Requirements   dispatchable   Semantics  sml::utility::make_dispatch_table T, 0, 10 (sm);  Example  struct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event  ) {}\n};\n\nauto dispatch_event = sml::utility::make_dispatch_table runtime_event, 1 /*min*/, 5 /*max*/ (sm);\ndispatch_event(event, event.id);    Dispatch Table Example   SDL2 Integration Example", 
            "title": "make_dispatch_table [utility]"
        }, 
        {
            "location": "/examples/index.html", 
            "text": "Hello World\n\n\nEvents\n\n\nStates\n\n\nActions Guards\n\n\nTransitions\n\n\nDefer/Process\n\n\nOrthogonal Regions\n\n\nComposite\n\n\nHistory\n\n\nError handling\n\n\nLogging\n\n\nTesting\n\n\nRuntime Dispatcher\n\n\neUML Emulation\n\n\nDependencies\n\n\nDependency Injection\n\n\nSDL2 Integration\n\n\nPlant UML Integration\n\n\n\n\n\n\nHello World\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n\nnamespace sml = boost::sml;\n\nstruct release {};\nstruct ack {};\nstruct fin {};\nstruct timeout {};\n\nconst auto is_ack_valid = [](const ack\n) { return true; };\nconst auto is_fin_valid = [](const fin\n) { return true; };\n\nconst auto send_fin = [] {};\nconst auto send_ack = [] {};\n\n#if !defined(_MSC_VER)\nstruct hello_world {\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n      *\nestablished\n_s + event\nrelease\n / send_fin = \nfin wait 1\n_s,\n       \nfin wait 1\n_s + event\nack\n [ is_ack_valid ] = \nfin wait 2\n_s,\n       \nfin wait 2\n_s + event\nfin\n [ is_fin_valid ] / send_ack = \ntimed wait\n_s,\n       \ntimed wait\n_s + event\ntimeout\n / send_ack = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n\n  sm\nhello_world\n sm;\n  static_assert(1 == sizeof(sm), \nsizeof(sm) != 1b\n);\n  assert(sm.is(\nestablished\n_s));\n\n  sm.process_event(release{});\n  assert(sm.is(\nfin wait 1\n_s));\n\n  sm.process_event(ack{});\n  assert(sm.is(\nfin wait 2\n_s));\n\n  sm.process_event(fin{});\n  assert(sm.is(\ntimed wait\n_s));\n\n  sm.process_event(timeout{});\n  assert(sm.is(X));  // released\n}\n#else\nclass established;\nclass fin_wait_1;\nclass fin_wait_2;\nclass timed_wait;\n\nstruct hello_world {\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n      *state\nestablished\n + event\nrelease\n / send_fin = state\nfin_wait_1\n,\n       state\nfin_wait_1\n + event\nack\n [ is_ack_valid ] = state\nfin_wait_2\n,\n       state\nfin_wait_2\n + event\nfin\n [ is_fin_valid ] / send_ack = state\ntimed_wait\n,\n       state\ntimed_wait\n + event\ntimeout\n / send_ack = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n\n  sm\nhello_world\n sm;\n  assert(sm.is(state\nestablished\n));\n\n  sm.process_event(release{});\n  assert(sm.is(state\nfin_wait_1\n));\n\n  sm.process_event(ack{});\n  assert(sm.is(state\nfin_wait_2\n));\n\n  sm.process_event(fin{});\n  assert(sm.is(state\ntimed_wait\n));\n\n  sm.process_event(timeout{});\n  assert(sm.is(X));  // released\n}\n#endif\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/hello_world.cpp\n\n\n\n\nEvents\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {\n  bool value = true;\n};\nauto event2 = sml::event\ne2\n;\nstruct e4 {\n  int value = 0;\n};\n\nstruct events {\n  auto operator()() const noexcept {\n    using namespace sml;\n    auto guard = [](const e2\n e) { return e.value; };\n\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event2 [guard] = \ns2\n_s\n      , \ns2\n_s + \ne3\n_e = \ns3\n_s\n      , \ns3\n_s + event\ne4\n / [] (const auto\n e) { assert(42 == e.value); } = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\nevents\n sm;\n  using namespace sml;\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event(\ne3\n_e());\n  sm.process_event(e4{42});\n  assert(sm.is(X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/events.cpp\n\n\n\n\nStates\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct states {\n  auto operator()() const noexcept {\n    using namespace sml;\n    const auto idle = state\nclass idle\n;\n    return make_transition_table(\n       *idle + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + sml::on_entry\n_\n / [] { std::cout \n \ns1 on entry\n \n std::endl; }\n      , \ns1\n_s + sml::on_exit\n_\n / [] { std::cout \n \ns1 on exit\n \n std::endl; }\n      , \ns1\n_s + event\ne2\n = state\nclass s2\n\n      , state\nclass s2\n + event\ne3\n = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\nstates\n sm;\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event(e3{});\n  assert(sm.is(sml::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/states.cpp\n\n\n\n\nActions Guards\n\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n#include \ntypeinfo\n\n\nnamespace sml = boost::sml;\n\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\nstruct e5 {};\n\nauto guard1 = [] {\n  std::cout \n \nguard1\n \n std::endl;\n  return true;\n};\n\nauto guard2 = [](int i) {\n  assert(42 == i);\n  std::cout \n \nguard2\n \n std::endl;\n  return false;\n};\n\nbool guard3(int i) {\n  assert(42 == i);\n  std::cout \n \nguard3\n \n std::endl;\n  return true;\n}\n\nauto action1 = [](auto e) { std::cout \n \naction1: \n \n typeid(e).name() \n std::endl; };\nstruct action2 {\n  void operator()(int i) {\n    assert(42 == i);\n    std::cout \n \naction2\n \n std::endl;\n  }\n};\n\nstruct actions_guards {\n  auto operator()() noexcept {\n    using namespace sml;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n [ guard1 ] / action1 = \ns2\n_s\n      , \ns2\n_s + event\ne3\n [ guard1 \n ![] { return false;} ] / (action1, action2{}) = \ns3\n_s\n      , \ns3\n_s + event\ne4\n [ !guard1 || guard2 ] / (action1, [] { std::cout \n \naction3\n \n std::endl; }) = \ns4\n_s\n      , \ns3\n_s + event\ne4\n [ guard1 ] / ([] { std::cout \n \naction4\n \n std::endl; }, [this] { action4(); }) = \ns5\n_s\n      , \ns5\n_s + event\ne5\n [ call(guard3) || guard2 ] / call(this, \nactions_guards::action5) = X\n    );\n  }\n\n  void action4() const { std::cout \n \naction4\n \n std::endl; }\n\n  void action5(int i, const e5\n) {\n    assert(42 == i);\n    std::cout \n \naction5\n \n std::endl;\n  }\n};\n\nint main() {\n  sml::sm\nactions_guards\n sm{42};\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event(e3{});\n  sm.process_event(e4{});\n  sm.process_event(e5{});\n  assert(sm.is(sml::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/actions_guards.cpp\n\n\n\n\nTransitions\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct transitions {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       *\nidle\n_s                  / [] { std::cout \n \nanonymous transition\n \n std::endl; } = \ns1\n_s\n      , \ns1\n_s + event\ne1\n        / [] { std::cout \n \ninternal transition\n \n std::endl; }\n      , \ns1\n_s + event\ne2\n        / [] { std::cout \n \nself transition\n \n std::endl; } = \ns1\n_s\n      , \ns1\n_s + sml::on_entry\n_\n / [] { std::cout \n \ns1 entry\n \n std::endl; }\n      , \ns1\n_s + sml::on_exit\n_\n  / [] { std::cout \n \ns1 exit\n \n std::endl; }\n      , \ns1\n_s + event\ne3\n        / [] { std::cout \n \nexternal transition\n \n std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\ntransitions\n sm;\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event(e3{});\n  assert(sm.is(sml::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/transitions.cpp\n\n\n\n\nDefer/Process\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \nqueue\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nstruct defer_and_process {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n / defer\n      , \nidle\n_s + event\ne2\n = \ns1\n_s\n      , \ns1\n_s   + event\ne1\n = \ns2\n_s\n      , \ns2\n_s   + event\ne3\n / process(e4{})\n      , \ns2\n_s   + event\ne4\n = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n  sm\ndefer_and_process, sml::defer_queue\nstd::queue\n sm;  /// defer_queue policy to enable deferred events using std::queue\n  assert(sm.is(\nidle\n_s));\n\n  sm.process_event(e1{});\n  assert(sm.is(\nidle\n_s));\n\n  sm.process_event(e2{});  /// triggers idle -\n s1 and s1 -\n s2 (via deferred e1)\n  assert(sm.is(\ns2\n_s));\n\n  sm.process_event(e3{});  /// triggers s2.process(e4) -\n X (via processed e4)\n  assert(sm.is(sml::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/defer_and_process.cpp\n\n\n\n\nOrthogonal Regions\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct orthogonal_regions {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n     *\nidle\n_s + event\ne1\n = \ns1\n_s\n    , \ns1\n_s + event\ne2\n = X\n\n    ,*\nidle2\n_s + event\ne2\n = \ns2\n_s\n    , \ns2\n_s + event\ne3\n = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\northogonal_regions\n sm;\n  using namespace sml;\n  assert(sm.is(\nidle\n_s, \nidle2\n_s));\n  sm.process_event(e1{});\n  assert(sm.is(\ns1\n_s, \nidle2\n_s));\n  sm.process_event(e2{});\n  assert(sm.is(X, \ns2\n_s));\n  sm.process_event(e3{});\n  assert(sm.is(X, X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/orthogonal_regions.cpp\n\n\n\n\nComposite\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\nstruct e5 {};\n\nstruct sub {\n  auto operator()() const noexcept {\n    using namespace sml;\n      return make_transition_table(\n       *\nidle\n_s + event\ne3\n / [] { std::cout \n \nin sub sm\n \n std::endl; } = \ns1\n_s\n      , \ns1\n_s + event\ne4\n / [] { std::cout \n \nfinish sub sm\n \n std::endl; } = X\n      );\n  }\n};\n\nstruct composite {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n     *\nidle\n_s + event\ne1\n = \ns1\n_s\n    , \ns1\n_s + event\ne2\n / [] { std::cout \n \nenter sub sm\n \n std::endl; } = state\nsub\n\n    , state\nsub\n + event\ne5\n / [] { std::cout \n \nexit sub sm\n \n std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\ncomposite\n sm;\n\n  using namespace sml;\n  assert(sm.is(\nidle\n_s));\n  assert(sm.is\ndecltype(state\nsub\n)\n(\nidle\n_s));\n\n  sm.process_event(e1{});\n  assert(sm.is(\ns1\n_s));\n  assert(sm.is\ndecltype(state\nsub\n)\n(\nidle\n_s));\n\n  sm.process_event(e2{});  // enter sub sm\n  assert(sm.is(state\nsub\n));\n  assert(sm.is\ndecltype(state\nsub\n)\n(\nidle\n_s));\n\n  sm.process_event(e3{});  // in sub sm\n  assert(sm.is(state\nsub\n));\n  assert(sm.is\ndecltype(state\nsub\n)\n(\ns1\n_s));\n\n  sm.process_event(e4{});  // finish sub sm\n  assert(sm.is(state\nsub\n));\n  assert(sm.is\ndecltype(state\nsub\n)\n(X));\n\n  sm.process_event(e5{});  // exit sub sm\n  assert(sm.is(X));\n  assert(sm.is\ndecltype(state\nsub\n)\n(X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/composite.cpp\n\n\n\n\nHistory\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace sml = boost::sml;\n\nstruct sub {\n  auto operator()() const noexcept {\n    using namespace sml;\n      return make_transition_table(\n        \ns1\n_s \n= \nidle\n_s(H) + \ne1\n_e / [] { std::cout \n \nin sub\n \n std::endl; }\n      , X      \n= \ns1\n_s      + \ne2\n_e / [] { std::cout \n \nin sub again\n \n std::endl; }\n      );\n  }\n};\n\nstruct history {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n      state\nsub\n \n= *\nidle\n_s  + \ne1\n_e / [] { std::cout \n \nenter sub\n \n std::endl; }\n    , \ns1\n_s     \n= state\nsub\n + \ne3\n_e / [] { std::cout \n \nexit sub\n \n std::endl; }\n    , state\nsub\n \n= \ns1\n_s     + \ne4\n_e / [] { std::cout \n \nenter sub again\n \n std::endl; }\n    );\n  }\n};\n\nint main() {\n  sml::sm\nhistory\n sm;\n  using namespace sml;\n  sm.process_event(\ne1\n_e());\n  sm.process_event(\ne1\n_e());  // enter sub\n  sm.process_event(\ne3\n_e());  // exit sub\n  sm.process_event(\ne4\n_e());  // enter sub\n  sm.process_event(\ne2\n_e());  // in sub again (history)\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/history.cpp\n\n\n\n\nError handling\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n#include \nstdexcept\n\n\nnamespace sml = boost::sml;\n\nstruct some_event {};\n\nstruct error_handling {\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n        *(\nidle\n_s) + \nevent1\n_e / [] { throw std::runtime_error{\nerror\n}; }\n      ,   \nidle\n_s  + \nevent2\n_e / [] { throw 0; }\n\n      , *(\nexceptions handling\n_s) + exception\nstd::runtime_error\n / [] { std::cout \n \nexception caught\n \n std::endl; }\n      ,   \nexceptions handling\n_s  + exception\n_\n / [] { std::cout \n \ngeneric exception caught\n \n std::endl; } = X\n\n      , *(\nunexpected events handling\n_s) + unexpected_event\nsome_event\n / [] { std::cout \n \nunexpected event 'some_event'\n \n std::endl; }\n      ,   \nunexpected events handling\n_s  + unexpected_event\n_\n / [] { std::cout \n \ngeneric unexpected event\n \n std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n  sm\nerror_handling\n sm;\n\n  sm.process_event(\nevent1\n_e());  // throws runtime_error\n  assert(sm.is(\nidle\n_s, \nexceptions handling\n_s, \nunexpected events handling\n_s));\n\n  sm.process_event(\nevent2\n_e());  // throws 0\n  assert(sm.is(\nidle\n_s, X, \nunexpected events handling\n_s));\n\n  sm.process_event(some_event{});  // unexpected event\n  assert(sm.is(\nidle\n_s, X, \nunexpected events handling\n_s));\n\n  sm.process_event(int{});  // unexpected any event\n  assert(sm.is(\nidle\n_s, X, X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/error_handling.cpp\n\n\n\n\nLogging\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \ncstdio\n\n#include \niostream\n\n\nnamespace sml = boost::sml;\n\nstruct my_logger {\n  template \nclass SM, class TEvent\n\n  void log_process_event(const TEvent\n) {\n    printf(\n[%s][process_event] %s\\n\n, sml::aux::get_type_name\nSM\n(), sml::aux::get_type_name\nTEvent\n());\n  }\n\n  template \nclass SM, class TGuard, class TEvent\n\n  void log_guard(const TGuard\n, const TEvent\n, bool result) {\n    printf(\n[%s][guard] %s %s %s\\n\n, sml::aux::get_type_name\nSM\n(), sml::aux::get_type_name\nTGuard\n(),\n           sml::aux::get_type_name\nTEvent\n(), (result ? \n[OK]\n : \n[Reject]\n));\n  }\n\n  template \nclass SM, class TAction, class TEvent\n\n  void log_action(const TAction\n, const TEvent\n) {\n    printf(\n[%s][action] %s %s\\n\n, sml::aux::get_type_name\nSM\n(), sml::aux::get_type_name\nTAction\n(),\n           sml::aux::get_type_name\nTEvent\n());\n  }\n\n  template \nclass SM, class TSrcState, class TDstState\n\n  void log_state_change(const TSrcState\n src, const TDstState\n dst) {\n    printf(\n[%s][transition] %s -\n %s\\n\n, sml::aux::get_type_name\nSM\n(), src.c_str(), dst.c_str());\n  }\n};\n\nstruct e1 {};\nstruct e2 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct logging {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n [ guard \n guard ] / action = \ns1\n_s\n    );\n  }\n};\n\nint main() {\n  my_logger logger;\n  sml::sm\nlogging, sml::logger\nmy_logger\n sm{logger};\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/logging.cpp\n\n\n\n\nTesting\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct data {\n  int value = 0;\n};\n\nstruct testing {\n  auto operator()() const noexcept {\n    using namespace sml;\n\n    const auto guard = [](data\n d) { return !d.value; };\n    const auto action = [](data\n d) { d.value = 42; };\n\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n = \ns2\n_s\n      , \ns2\n_s + event\ne3\n [guard] / action = X // transition under test\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n  data fake_data{0};\n  sml::sm\n::testing, sml::testing\n sm{fake_data};\n  sm.__set_current_states(\ns2\n_s);\n  sm.process_event(e3{});\n  assert(sm.is(X));\n  assert(fake_data.value = 42);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/testing.cpp\n\n\n\n\nRuntime Dispatcher\n\n\n#include \nboost/sml/utility/dispatch_table.hpp\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n\nnamespace sml = boost::sml;\n\nstruct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event \n) {}\n};\nstruct event2 {\n  static constexpr auto id = 2;\n};\n\nstruct dispatch_table {\n  auto operator()() noexcept {\n    using namespace sml;\n    return make_transition_table(\n       *\nidle\n_s + event\nevent1\n = \ns1\n_s\n      , \ns1\n_s + event\nevent2\n = X\n    );\n  }\n};\n\nint main() {\n  sml::sm\ndispatch_table\n sm;\n\n  auto dispatch_event = sml::utility::make_dispatch_table\nruntime_event, 1 /*min*/, 5 /*max*/\n(sm);\n\n  {\n    runtime_event event{1};\n    dispatch_event(event, event.id);\n  }\n\n  {\n    runtime_event event{2};\n    dispatch_event(event, event.id);\n  }\n\n  assert(sm.is(sml::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/dispatch_table.cpp\n\n\n\n\neUML Emulation\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto event1 = sml::event\ne1\n;\nauto event2 = sml::event\ne2\n;\nauto event3 = sml::event\ne3\n;\n\nauto idle = sml::state\nclass idle\n;\nauto s1 = sml::state\nclass s1\n;\nauto s2 = sml::state\nclass s2\n;\n\nclass euml_emulation;\n\nstruct Guard {\n  template \nclass TEvent\n\n  bool operator()(euml_emulation\n, const TEvent\n) const;\n} guard;\n\nstruct Action {\n  template \nclass TEvent\n\n  void operator()(euml_emulation\n, const TEvent\n);\n} action;\n\nclass euml_emulation {\n public:\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n      s1 \n= *idle + event1,\n      s2 \n= s1    + event2 [ guard ],\n      X  \n= s2    + event3 [ guard ] / action\n    );\n  }\n\n  template \nclass TEvent\n\n  bool call_guard(const TEvent\n) {\n    return true;\n  }\n\n  void call_action(const e3\n) {}\n};\n\ntemplate \nclass TEvent\n\nbool Guard::operator()(euml_emulation\n sm, const TEvent\n event) const {\n  return sm.call_guard(event);\n}\n\ntemplate \nclass TEvent\n\nvoid Action::operator()(euml_emulation\n sm, const TEvent\n event) {\n  sm.call_action(event);\n}\n\nint main() {\n  euml_emulation euml;\n  sml::sm\neuml_emulation\n sm{euml};\n  assert(sm.is(idle));\n  sm.process_event(e1{});\n  assert(sm.is(s1));\n  sm.process_event(e2{});\n  assert(sm.is(s2));\n  sm.process_event(e3{});\n  assert(sm.is(sml::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/euml_emulation.cpp\n\n\n\n\nDependencies\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \nqueue\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {\n  int i = 0;\n};\nstruct dependency {\n  int i = 0;\n};\n\nstruct dependencies {\n  auto operator()() const noexcept {\n    using namespace sml;\n\n    const auto guard = [](dependency\n d) {  /// more dependencies might be passed\n      return !d.i;\n    };\n\n    const auto action = [](dependency\n d,\n                           const auto\n event) {  /// event is deduced, order is not important\n      d.i = event.i + 42;\n    };\n\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n [ guard ] / action = \ns1\n_s\n      , \ns1\n_s   + event\ne1\n [ ([](const auto\n event, dependency\n d) { return d.i == event.i; }) ] = X\n     );\n  }\n};\n\nint main() {\n  using namespace sml;\n  dependency d;\n  sm\ndependencies\n sm{d};  /// pass all dependencies (from guards, actions) via\n                           /// constructor (order is not important)\n  assert(sm.is(\nidle\n_s));\n\n  sm.process_event(e1{0});\n  assert(sm.is(\ns1\n_s));  /// action sets dependency.i to 42\n\n  sm.process_event(e1{0});\n  assert(sm.is(\ns1\n_s));  /// not satisfied, dependency.i(42) != event.i(0)\n\n  sm.process_event(e1{42});\n  assert(sm.is(X));  /// transition to X\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/dependencies.cpp\n\n\n\n\nDependency Injection\n\n\n#if __has_include(\nboost/di.hpp\n)\n#include \nboost/sml.hpp\n\n#include \nboost/di.hpp\n\n#include \ncassert\n\n#include \ntypeinfo\n\n#include \niostream\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto guard = [](int i, double d) {\n  assert(42 == i);\n  assert(87.0 == d);\n  std::cout \n \nguard\n \n std::endl;\n  return true;\n};\n\nauto action = [](int i, auto e) {\n  assert(42 == i);\n  std::cout \n \naction: \n \n typeid(e).name() \n std::endl;\n};\n\nstruct example {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n [ guard ] / action = \ns2\n_s\n      , \ns2\n_s + event\ne3\n / [] { std::cout \n \nin place action\n \n std::endl; } = X\n    );\n  }\n};\n\nnamespace di = boost::di;\n\nclass controller {\n public:\n  explicit controller(sml::sm\nexample\n sm) : sm(sm) {}\n\n  void start() {\n    sm.process_event(e1{});\n    sm.process_event(e2{});\n    sm.process_event(e3{});\n    assert(sm.is(sml::X));\n  }\n\n private:\n  sml::sm\nexample\n sm;\n};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind\n.to(42)\n  , di::bind\n.to(87.0)\n  );\n  injector.create\ncontroller\n().start();\n}\n#else\nint main() {}\n#endif\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/dependency_injection.cpp\n\n\n\n\nSDL2 Integration\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n#include \nboost/sml/utility/dispatch_table.hpp\n\n\nnamespace sml = boost::sml;\n\n#if __has_include(\nSDL2/SDL_events.h\n)\n#include \nSDL2/SDL_events.h\n\n#else\nenum { SDLK_SPACE = ' ' };\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\nstruct SDL_KeyboardEvent {\n  SDL_EventType type;\n  struct {\n    int sym;\n  } keysym;\n};\nstruct SDL_MouseButtonEvent {\n  SDL_EventType type;\n  int button;\n};\nstruct SDL_QuitEvent {\n  SDL_EventType type;\n};\nunion SDL_Event {\n  SDL_EventType type;\n  SDL_KeyboardEvent key;\n  SDL_MouseButtonEvent button;\n  SDL_QuitEvent quit;\n};\n#endif\n\ntemplate \nSDL_EventType Id\n\nstruct sdl_event_impl {\n  static constexpr auto id = Id;\n  explicit sdl_event_impl(const SDL_Event\n data) noexcept : data(data) {}\n  SDL_Event data;\n};\n\ntemplate \nSDL_EventType Id\n\ndecltype(sml::event\nsdl_event_impl\nId\n) sdl_event{};\n\nstruct IsKey {\n  auto operator()(int key) {\n    return [=](auto event) { return event.data.key.keysym.sym == key; };\n  }\n} is_key;\n\nstruct sdl2 {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n      //------------------------------------------------------------------------------//\n        \nwait_for_user_input\n_s \n= *\nidle\n_s\n          / [] { std::cout \n \ninitialization\n \n std::endl; }\n\n      , \nkey_pressed\n_s \n= \nwait_for_user_input\n_s + sdl_event\nSDL_KEYUP\n [ is_key(SDLK_SPACE) ]\n          / [] { std::cout \n \nspace pressed\n \n std::endl; }\n\n      , X \n= \nkey_pressed\n_s + sdl_event\nSDL_MOUSEBUTTONUP\n\n          / [] { std::cout \n \nmouse button pressed\n \n std::endl; }\n      //------------------------------------------------------------------------------//\n      , X \n= *\nwaiting_for_quit\n_s + sdl_event\nSDL_QUIT\n\n          / [] { std::cout \n \nquit\n \n std::endl; }\n      //------------------------------------------------------------------------------//\n    );\n  }\n};\n\nint main() {\n  sml::sm\nsdl2\n sm;\n  auto dispatch_event = sml::utility::make_dispatch_table\nSDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT\n(sm);\n\n  SDL_Event event;\n\n  // while (SDL_PollEvent(\nevent)) {\n  //   dispatch_event(event, event.type)\n  // };\n\n  {\n    SDL_KeyboardEvent keyboard_event;\n    keyboard_event.type = SDL_KEYUP;\n    keyboard_event.keysym.sym = SDLK_SPACE;\n    event.key = keyboard_event;\n    dispatch_event(event, event.type);\n  }\n\n  {\n    SDL_MouseButtonEvent mousebutton_event;\n    mousebutton_event.type = SDL_MOUSEBUTTONUP;\n    mousebutton_event.button = 1;\n    event.button = mousebutton_event;\n    dispatch_event(event, event.type);\n  }\n\n  {\n    SDL_QuitEvent quit_event;\n    quit_event.type = SDL_QUIT;\n    event.quit = quit_event;\n    dispatch_event(event, event.type);\n  }\n\n  assert(sm.is(sml::X, sml::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/sdl2.cpp\n\n\n\n\nPlant UML Integration\n\n\n#include \nboost/sml.hpp\n\n#include \ncassert\n\n#include \niostream\n\n#include \nstring\n\n#include \ntypeinfo\n\n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct plant_uml {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n [ guard ] / action = \ns2\n_s\n      , \ns2\n_s + event\ne3\n [ guard ] = \ns1\n_s\n      , \ns2\n_s + event\ne4\n / action = X\n    );\n  }\n};\n\ntemplate \nclass T\n\nvoid dump_transition() noexcept {\n  auto src_state = std::string{sml::aux::string\ntypename T::src_state\n{}.c_str()};\n  auto dst_state = std::string{sml::aux::string\ntypename T::dst_state\n{}.c_str()};\n  if (dst_state == \nX\n) {\n    dst_state = \n[*]\n;\n  }\n\n  if (T::initial) {\n    std::cout \n \n[*] --\n \n \n src_state \n std::endl;\n  }\n\n  std::cout \n src_state \n \n --\n \n \n dst_state;\n\n  const auto has_event = !sml::aux::is_same\ntypename T::event, sml::anonymous\n::value;\n  const auto has_guard = !sml::aux::is_same\ntypename T::guard, sml::front::always\n::value;\n  const auto has_action = !sml::aux::is_same\ntypename T::action, sml::front::none\n::value;\n\n  if (has_event || has_guard || has_action) {\n    std::cout \n \n :\n;\n  }\n\n  if (has_event) {\n    std::cout \n \n \n \n typeid(typename T::event).name();\n  }\n\n  if (has_guard) {\n    std::cout \n \n [\n \n typeid(typename T::guard).name() \n \n]\n;\n  }\n\n  if (has_action) {\n    std::cout \n \n / \n \n typeid(typename T::action).name();\n  }\n\n  std::cout \n std::endl;\n}\n\ntemplate \ntemplate \nclass...\n class T, class... Ts\n\nvoid dump_transitions(const T\nTs...\n) noexcept {\n  int _[]{0, (dump_transition\nTs\n(), 0)...};\n  (void)_;\n}\n\ntemplate \nclass SM\n\nvoid dump(const SM\n) noexcept {\n  std::cout \n \n@startuml\n \n std::endl \n std::endl;\n  dump_transitions(typename SM::transitions{});\n  std::cout \n std::endl \n \n@enduml\n \n std::endl;\n}\n\nint main() {\n  sml::sm\nplant_uml\n sm;\n  dump(sm);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/sml/master/example/plant_uml.cpp", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/index.html#hello-world", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n\nnamespace sml = boost::sml;\n\nstruct release {};\nstruct ack {};\nstruct fin {};\nstruct timeout {};\n\nconst auto is_ack_valid = [](const ack ) { return true; };\nconst auto is_fin_valid = [](const fin ) { return true; };\n\nconst auto send_fin = [] {};\nconst auto send_ack = [] {};\n\n#if !defined(_MSC_VER)\nstruct hello_world {\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n      * established _s + event release  / send_fin =  fin wait 1 _s,\n        fin wait 1 _s + event ack  [ is_ack_valid ] =  fin wait 2 _s,\n        fin wait 2 _s + event fin  [ is_fin_valid ] / send_ack =  timed wait _s,\n        timed wait _s + event timeout  / send_ack = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n\n  sm hello_world  sm;\n  static_assert(1 == sizeof(sm),  sizeof(sm) != 1b );\n  assert(sm.is( established _s));\n\n  sm.process_event(release{});\n  assert(sm.is( fin wait 1 _s));\n\n  sm.process_event(ack{});\n  assert(sm.is( fin wait 2 _s));\n\n  sm.process_event(fin{});\n  assert(sm.is( timed wait _s));\n\n  sm.process_event(timeout{});\n  assert(sm.is(X));  // released\n}\n#else\nclass established;\nclass fin_wait_1;\nclass fin_wait_2;\nclass timed_wait;\n\nstruct hello_world {\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n      *state established  + event release  / send_fin = state fin_wait_1 ,\n       state fin_wait_1  + event ack  [ is_ack_valid ] = state fin_wait_2 ,\n       state fin_wait_2  + event fin  [ is_fin_valid ] / send_ack = state timed_wait ,\n       state timed_wait  + event timeout  / send_ack = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n\n  sm hello_world  sm;\n  assert(sm.is(state established ));\n\n  sm.process_event(release{});\n  assert(sm.is(state fin_wait_1 ));\n\n  sm.process_event(ack{});\n  assert(sm.is(state fin_wait_2 ));\n\n  sm.process_event(fin{});\n  assert(sm.is(state timed_wait ));\n\n  sm.process_event(timeout{});\n  assert(sm.is(X));  // released\n}\n#endif   https://raw.githubusercontent.com/boost-experimental/sml/master/example/hello_world.cpp", 
            "title": "Hello World"
        }, 
        {
            "location": "/examples/index.html#events", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {\n  bool value = true;\n};\nauto event2 = sml::event e2 ;\nstruct e4 {\n  int value = 0;\n};\n\nstruct events {\n  auto operator()() const noexcept {\n    using namespace sml;\n    auto guard = [](const e2  e) { return e.value; };\n\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event2 [guard] =  s2 _s\n      ,  s2 _s +  e3 _e =  s3 _s\n      ,  s3 _s + event e4  / [] (const auto  e) { assert(42 == e.value); } = X\n    );\n  }\n};\n\nint main() {\n  sml::sm events  sm;\n  using namespace sml;\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event( e3 _e());\n  sm.process_event(e4{42});\n  assert(sm.is(X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/events.cpp", 
            "title": "Events"
        }, 
        {
            "location": "/examples/index.html#states", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct states {\n  auto operator()() const noexcept {\n    using namespace sml;\n    const auto idle = state class idle ;\n    return make_transition_table(\n       *idle + event e1  =  s1 _s\n      ,  s1 _s + sml::on_entry _  / [] { std::cout    s1 on entry    std::endl; }\n      ,  s1 _s + sml::on_exit _  / [] { std::cout    s1 on exit    std::endl; }\n      ,  s1 _s + event e2  = state class s2 \n      , state class s2  + event e3  = X\n    );\n  }\n};\n\nint main() {\n  sml::sm states  sm;\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event(e3{});\n  assert(sm.is(sml::X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/states.cpp", 
            "title": "States"
        }, 
        {
            "location": "/examples/index.html#actions-guards", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n#include  typeinfo \n\nnamespace sml = boost::sml;\n\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\nstruct e5 {};\n\nauto guard1 = [] {\n  std::cout    guard1    std::endl;\n  return true;\n};\n\nauto guard2 = [](int i) {\n  assert(42 == i);\n  std::cout    guard2    std::endl;\n  return false;\n};\n\nbool guard3(int i) {\n  assert(42 == i);\n  std::cout    guard3    std::endl;\n  return true;\n}\n\nauto action1 = [](auto e) { std::cout    action1:     typeid(e).name()   std::endl; };\nstruct action2 {\n  void operator()(int i) {\n    assert(42 == i);\n    std::cout    action2    std::endl;\n  }\n};\n\nstruct actions_guards {\n  auto operator()() noexcept {\n    using namespace sml;\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  [ guard1 ] / action1 =  s2 _s\n      ,  s2 _s + event e3  [ guard1   ![] { return false;} ] / (action1, action2{}) =  s3 _s\n      ,  s3 _s + event e4  [ !guard1 || guard2 ] / (action1, [] { std::cout    action3    std::endl; }) =  s4 _s\n      ,  s3 _s + event e4  [ guard1 ] / ([] { std::cout    action4    std::endl; }, [this] { action4(); }) =  s5 _s\n      ,  s5 _s + event e5  [ call(guard3) || guard2 ] / call(this,  actions_guards::action5) = X\n    );\n  }\n\n  void action4() const { std::cout    action4    std::endl; }\n\n  void action5(int i, const e5 ) {\n    assert(42 == i);\n    std::cout    action5    std::endl;\n  }\n};\n\nint main() {\n  sml::sm actions_guards  sm{42};\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event(e3{});\n  sm.process_event(e4{});\n  sm.process_event(e5{});\n  assert(sm.is(sml::X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/actions_guards.cpp", 
            "title": "Actions Guards"
        }, 
        {
            "location": "/examples/index.html#transitions", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct transitions {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       * idle _s                  / [] { std::cout    anonymous transition    std::endl; } =  s1 _s\n      ,  s1 _s + event e1         / [] { std::cout    internal transition    std::endl; }\n      ,  s1 _s + event e2         / [] { std::cout    self transition    std::endl; } =  s1 _s\n      ,  s1 _s + sml::on_entry _  / [] { std::cout    s1 entry    std::endl; }\n      ,  s1 _s + sml::on_exit _   / [] { std::cout    s1 exit    std::endl; }\n      ,  s1 _s + event e3         / [] { std::cout    external transition    std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  sml::sm transitions  sm;\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n  sm.process_event(e3{});\n  assert(sm.is(sml::X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/transitions.cpp", 
            "title": "Transitions"
        }, 
        {
            "location": "/examples/index.html#deferprocess", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  queue \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nstruct defer_and_process {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       * idle _s + event e1  / defer\n      ,  idle _s + event e2  =  s1 _s\n      ,  s1 _s   + event e1  =  s2 _s\n      ,  s2 _s   + event e3  / process(e4{})\n      ,  s2 _s   + event e4  = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n  sm defer_and_process, sml::defer_queue std::queue  sm;  /// defer_queue policy to enable deferred events using std::queue\n  assert(sm.is( idle _s));\n\n  sm.process_event(e1{});\n  assert(sm.is( idle _s));\n\n  sm.process_event(e2{});  /// triggers idle -  s1 and s1 -  s2 (via deferred e1)\n  assert(sm.is( s2 _s));\n\n  sm.process_event(e3{});  /// triggers s2.process(e4) -  X (via processed e4)\n  assert(sm.is(sml::X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/defer_and_process.cpp", 
            "title": "Defer/Process"
        }, 
        {
            "location": "/examples/index.html#orthogonal-regions", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct orthogonal_regions {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n     * idle _s + event e1  =  s1 _s\n    ,  s1 _s + event e2  = X\n\n    ,* idle2 _s + event e2  =  s2 _s\n    ,  s2 _s + event e3  = X\n    );\n  }\n};\n\nint main() {\n  sml::sm orthogonal_regions  sm;\n  using namespace sml;\n  assert(sm.is( idle _s,  idle2 _s));\n  sm.process_event(e1{});\n  assert(sm.is( s1 _s,  idle2 _s));\n  sm.process_event(e2{});\n  assert(sm.is(X,  s2 _s));\n  sm.process_event(e3{});\n  assert(sm.is(X, X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/orthogonal_regions.cpp", 
            "title": "Orthogonal Regions"
        }, 
        {
            "location": "/examples/index.html#composite", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\nstruct e5 {};\n\nstruct sub {\n  auto operator()() const noexcept {\n    using namespace sml;\n      return make_transition_table(\n       * idle _s + event e3  / [] { std::cout    in sub sm    std::endl; } =  s1 _s\n      ,  s1 _s + event e4  / [] { std::cout    finish sub sm    std::endl; } = X\n      );\n  }\n};\n\nstruct composite {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n     * idle _s + event e1  =  s1 _s\n    ,  s1 _s + event e2  / [] { std::cout    enter sub sm    std::endl; } = state sub \n    , state sub  + event e5  / [] { std::cout    exit sub sm    std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  sml::sm composite  sm;\n\n  using namespace sml;\n  assert(sm.is( idle _s));\n  assert(sm.is decltype(state sub ) ( idle _s));\n\n  sm.process_event(e1{});\n  assert(sm.is( s1 _s));\n  assert(sm.is decltype(state sub ) ( idle _s));\n\n  sm.process_event(e2{});  // enter sub sm\n  assert(sm.is(state sub ));\n  assert(sm.is decltype(state sub ) ( idle _s));\n\n  sm.process_event(e3{});  // in sub sm\n  assert(sm.is(state sub ));\n  assert(sm.is decltype(state sub ) ( s1 _s));\n\n  sm.process_event(e4{});  // finish sub sm\n  assert(sm.is(state sub ));\n  assert(sm.is decltype(state sub ) (X));\n\n  sm.process_event(e5{});  // exit sub sm\n  assert(sm.is(X));\n  assert(sm.is decltype(state sub ) (X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/composite.cpp", 
            "title": "Composite"
        }, 
        {
            "location": "/examples/index.html#history", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n\nnamespace sml = boost::sml;\n\nstruct sub {\n  auto operator()() const noexcept {\n    using namespace sml;\n      return make_transition_table(\n         s1 _s  =  idle _s(H) +  e1 _e / [] { std::cout    in sub    std::endl; }\n      , X       =  s1 _s      +  e2 _e / [] { std::cout    in sub again    std::endl; }\n      );\n  }\n};\n\nstruct history {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n      state sub   = * idle _s  +  e1 _e / [] { std::cout    enter sub    std::endl; }\n    ,  s1 _s      = state sub  +  e3 _e / [] { std::cout    exit sub    std::endl; }\n    , state sub   =  s1 _s     +  e4 _e / [] { std::cout    enter sub again    std::endl; }\n    );\n  }\n};\n\nint main() {\n  sml::sm history  sm;\n  using namespace sml;\n  sm.process_event( e1 _e());\n  sm.process_event( e1 _e());  // enter sub\n  sm.process_event( e3 _e());  // exit sub\n  sm.process_event( e4 _e());  // enter sub\n  sm.process_event( e2 _e());  // in sub again (history)\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/history.cpp", 
            "title": "History"
        }, 
        {
            "location": "/examples/index.html#error-handling", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n#include  stdexcept \n\nnamespace sml = boost::sml;\n\nstruct some_event {};\n\nstruct error_handling {\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n        *( idle _s) +  event1 _e / [] { throw std::runtime_error{ error }; }\n      ,    idle _s  +  event2 _e / [] { throw 0; }\n\n      , *( exceptions handling _s) + exception std::runtime_error  / [] { std::cout    exception caught    std::endl; }\n      ,    exceptions handling _s  + exception _  / [] { std::cout    generic exception caught    std::endl; } = X\n\n      , *( unexpected events handling _s) + unexpected_event some_event  / [] { std::cout    unexpected event 'some_event'    std::endl; }\n      ,    unexpected events handling _s  + unexpected_event _  / [] { std::cout    generic unexpected event    std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n  sm error_handling  sm;\n\n  sm.process_event( event1 _e());  // throws runtime_error\n  assert(sm.is( idle _s,  exceptions handling _s,  unexpected events handling _s));\n\n  sm.process_event( event2 _e());  // throws 0\n  assert(sm.is( idle _s, X,  unexpected events handling _s));\n\n  sm.process_event(some_event{});  // unexpected event\n  assert(sm.is( idle _s, X,  unexpected events handling _s));\n\n  sm.process_event(int{});  // unexpected any event\n  assert(sm.is( idle _s, X, X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/error_handling.cpp", 
            "title": "Error handling"
        }, 
        {
            "location": "/examples/index.html#logging", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  cstdio \n#include  iostream \n\nnamespace sml = boost::sml;\n\nstruct my_logger {\n  template  class SM, class TEvent \n  void log_process_event(const TEvent ) {\n    printf( [%s][process_event] %s\\n , sml::aux::get_type_name SM (), sml::aux::get_type_name TEvent ());\n  }\n\n  template  class SM, class TGuard, class TEvent \n  void log_guard(const TGuard , const TEvent , bool result) {\n    printf( [%s][guard] %s %s %s\\n , sml::aux::get_type_name SM (), sml::aux::get_type_name TGuard (),\n           sml::aux::get_type_name TEvent (), (result ?  [OK]  :  [Reject] ));\n  }\n\n  template  class SM, class TAction, class TEvent \n  void log_action(const TAction , const TEvent ) {\n    printf( [%s][action] %s %s\\n , sml::aux::get_type_name SM (), sml::aux::get_type_name TAction (),\n           sml::aux::get_type_name TEvent ());\n  }\n\n  template  class SM, class TSrcState, class TDstState \n  void log_state_change(const TSrcState  src, const TDstState  dst) {\n    printf( [%s][transition] %s -  %s\\n , sml::aux::get_type_name SM (), src.c_str(), dst.c_str());\n  }\n};\n\nstruct e1 {};\nstruct e2 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct logging {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       * idle _s + event e1  [ guard   guard ] / action =  s1 _s\n    );\n  }\n};\n\nint main() {\n  my_logger logger;\n  sml::sm logging, sml::logger my_logger  sm{logger};\n  sm.process_event(e1{});\n  sm.process_event(e2{});\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/logging.cpp", 
            "title": "Logging"
        }, 
        {
            "location": "/examples/index.html#testing", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct data {\n  int value = 0;\n};\n\nstruct testing {\n  auto operator()() const noexcept {\n    using namespace sml;\n\n    const auto guard = [](data  d) { return !d.value; };\n    const auto action = [](data  d) { d.value = 42; };\n\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  =  s2 _s\n      ,  s2 _s + event e3  [guard] / action = X // transition under test\n    );\n  }\n};\n\nint main() {\n  using namespace sml;\n  data fake_data{0};\n  sml::sm ::testing, sml::testing  sm{fake_data};\n  sm.__set_current_states( s2 _s);\n  sm.process_event(e3{});\n  assert(sm.is(X));\n  assert(fake_data.value = 42);\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/testing.cpp", 
            "title": "Testing"
        }, 
        {
            "location": "/examples/index.html#runtime-dispatcher", 
            "text": "#include  boost/sml/utility/dispatch_table.hpp \n#include  boost/sml.hpp \n#include  cassert \n\nnamespace sml = boost::sml;\n\nstruct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event  ) {}\n};\nstruct event2 {\n  static constexpr auto id = 2;\n};\n\nstruct dispatch_table {\n  auto operator()() noexcept {\n    using namespace sml;\n    return make_transition_table(\n       * idle _s + event event1  =  s1 _s\n      ,  s1 _s + event event2  = X\n    );\n  }\n};\n\nint main() {\n  sml::sm dispatch_table  sm;\n\n  auto dispatch_event = sml::utility::make_dispatch_table runtime_event, 1 /*min*/, 5 /*max*/ (sm);\n\n  {\n    runtime_event event{1};\n    dispatch_event(event, event.id);\n  }\n\n  {\n    runtime_event event{2};\n    dispatch_event(event, event.id);\n  }\n\n  assert(sm.is(sml::X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/dispatch_table.cpp", 
            "title": "Runtime Dispatcher"
        }, 
        {
            "location": "/examples/index.html#euml-emulation", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto event1 = sml::event e1 ;\nauto event2 = sml::event e2 ;\nauto event3 = sml::event e3 ;\n\nauto idle = sml::state class idle ;\nauto s1 = sml::state class s1 ;\nauto s2 = sml::state class s2 ;\n\nclass euml_emulation;\n\nstruct Guard {\n  template  class TEvent \n  bool operator()(euml_emulation , const TEvent ) const;\n} guard;\n\nstruct Action {\n  template  class TEvent \n  void operator()(euml_emulation , const TEvent );\n} action;\n\nclass euml_emulation {\n public:\n  auto operator()() const {\n    using namespace sml;\n    return make_transition_table(\n      s1  = *idle + event1,\n      s2  = s1    + event2 [ guard ],\n      X   = s2    + event3 [ guard ] / action\n    );\n  }\n\n  template  class TEvent \n  bool call_guard(const TEvent ) {\n    return true;\n  }\n\n  void call_action(const e3 ) {}\n};\n\ntemplate  class TEvent \nbool Guard::operator()(euml_emulation  sm, const TEvent  event) const {\n  return sm.call_guard(event);\n}\n\ntemplate  class TEvent \nvoid Action::operator()(euml_emulation  sm, const TEvent  event) {\n  sm.call_action(event);\n}\n\nint main() {\n  euml_emulation euml;\n  sml::sm euml_emulation  sm{euml};\n  assert(sm.is(idle));\n  sm.process_event(e1{});\n  assert(sm.is(s1));\n  sm.process_event(e2{});\n  assert(sm.is(s2));\n  sm.process_event(e3{});\n  assert(sm.is(sml::X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/euml_emulation.cpp", 
            "title": "eUML Emulation"
        }, 
        {
            "location": "/examples/index.html#dependencies", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  queue \n\nnamespace sml = boost::sml;\n\nstruct e1 {\n  int i = 0;\n};\nstruct dependency {\n  int i = 0;\n};\n\nstruct dependencies {\n  auto operator()() const noexcept {\n    using namespace sml;\n\n    const auto guard = [](dependency  d) {  /// more dependencies might be passed\n      return !d.i;\n    };\n\n    const auto action = [](dependency  d,\n                           const auto  event) {  /// event is deduced, order is not important\n      d.i = event.i + 42;\n    };\n\n    return make_transition_table(\n       * idle _s + event e1  [ guard ] / action =  s1 _s\n      ,  s1 _s   + event e1  [ ([](const auto  event, dependency  d) { return d.i == event.i; }) ] = X\n     );\n  }\n};\n\nint main() {\n  using namespace sml;\n  dependency d;\n  sm dependencies  sm{d};  /// pass all dependencies (from guards, actions) via\n                           /// constructor (order is not important)\n  assert(sm.is( idle _s));\n\n  sm.process_event(e1{0});\n  assert(sm.is( s1 _s));  /// action sets dependency.i to 42\n\n  sm.process_event(e1{0});\n  assert(sm.is( s1 _s));  /// not satisfied, dependency.i(42) != event.i(0)\n\n  sm.process_event(e1{42});\n  assert(sm.is(X));  /// transition to X\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/dependencies.cpp", 
            "title": "Dependencies"
        }, 
        {
            "location": "/examples/index.html#dependency-injection", 
            "text": "#if __has_include( boost/di.hpp )\n#include  boost/sml.hpp \n#include  boost/di.hpp \n#include  cassert \n#include  typeinfo \n#include  iostream \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto guard = [](int i, double d) {\n  assert(42 == i);\n  assert(87.0 == d);\n  std::cout    guard    std::endl;\n  return true;\n};\n\nauto action = [](int i, auto e) {\n  assert(42 == i);\n  std::cout    action:     typeid(e).name()   std::endl;\n};\n\nstruct example {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  [ guard ] / action =  s2 _s\n      ,  s2 _s + event e3  / [] { std::cout    in place action    std::endl; } = X\n    );\n  }\n};\n\nnamespace di = boost::di;\n\nclass controller {\n public:\n  explicit controller(sml::sm example  sm) : sm(sm) {}\n\n  void start() {\n    sm.process_event(e1{});\n    sm.process_event(e2{});\n    sm.process_event(e3{});\n    assert(sm.is(sml::X));\n  }\n\n private:\n  sml::sm example  sm;\n};\n\nint main() {\n  const auto injector = di::make_injector(\n    di::bind .to(42)\n  , di::bind .to(87.0)\n  );\n  injector.create controller ().start();\n}\n#else\nint main() {}\n#endif   https://raw.githubusercontent.com/boost-experimental/sml/master/example/dependency_injection.cpp", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/examples/index.html#sdl2-integration", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n#include  boost/sml/utility/dispatch_table.hpp \n\nnamespace sml = boost::sml;\n\n#if __has_include( SDL2/SDL_events.h )\n#include  SDL2/SDL_events.h \n#else\nenum { SDLK_SPACE = ' ' };\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\nstruct SDL_KeyboardEvent {\n  SDL_EventType type;\n  struct {\n    int sym;\n  } keysym;\n};\nstruct SDL_MouseButtonEvent {\n  SDL_EventType type;\n  int button;\n};\nstruct SDL_QuitEvent {\n  SDL_EventType type;\n};\nunion SDL_Event {\n  SDL_EventType type;\n  SDL_KeyboardEvent key;\n  SDL_MouseButtonEvent button;\n  SDL_QuitEvent quit;\n};\n#endif\n\ntemplate  SDL_EventType Id \nstruct sdl_event_impl {\n  static constexpr auto id = Id;\n  explicit sdl_event_impl(const SDL_Event  data) noexcept : data(data) {}\n  SDL_Event data;\n};\n\ntemplate  SDL_EventType Id \ndecltype(sml::event sdl_event_impl Id ) sdl_event{};\n\nstruct IsKey {\n  auto operator()(int key) {\n    return [=](auto event) { return event.data.key.keysym.sym == key; };\n  }\n} is_key;\n\nstruct sdl2 {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n      //------------------------------------------------------------------------------//\n         wait_for_user_input _s  = * idle _s\n          / [] { std::cout    initialization    std::endl; }\n\n      ,  key_pressed _s  =  wait_for_user_input _s + sdl_event SDL_KEYUP  [ is_key(SDLK_SPACE) ]\n          / [] { std::cout    space pressed    std::endl; }\n\n      , X  =  key_pressed _s + sdl_event SDL_MOUSEBUTTONUP \n          / [] { std::cout    mouse button pressed    std::endl; }\n      //------------------------------------------------------------------------------//\n      , X  = * waiting_for_quit _s + sdl_event SDL_QUIT \n          / [] { std::cout    quit    std::endl; }\n      //------------------------------------------------------------------------------//\n    );\n  }\n};\n\nint main() {\n  sml::sm sdl2  sm;\n  auto dispatch_event = sml::utility::make_dispatch_table SDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT (sm);\n\n  SDL_Event event;\n\n  // while (SDL_PollEvent( event)) {\n  //   dispatch_event(event, event.type)\n  // };\n\n  {\n    SDL_KeyboardEvent keyboard_event;\n    keyboard_event.type = SDL_KEYUP;\n    keyboard_event.keysym.sym = SDLK_SPACE;\n    event.key = keyboard_event;\n    dispatch_event(event, event.type);\n  }\n\n  {\n    SDL_MouseButtonEvent mousebutton_event;\n    mousebutton_event.type = SDL_MOUSEBUTTONUP;\n    mousebutton_event.button = 1;\n    event.button = mousebutton_event;\n    dispatch_event(event, event.type);\n  }\n\n  {\n    SDL_QuitEvent quit_event;\n    quit_event.type = SDL_QUIT;\n    event.quit = quit_event;\n    dispatch_event(event, event.type);\n  }\n\n  assert(sm.is(sml::X, sml::X));\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/sdl2.cpp", 
            "title": "SDL2 Integration"
        }, 
        {
            "location": "/examples/index.html#plant-uml-integration", 
            "text": "#include  boost/sml.hpp \n#include  cassert \n#include  iostream \n#include  string \n#include  typeinfo \n\nnamespace sml = boost::sml;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct plant_uml {\n  auto operator()() const noexcept {\n    using namespace sml;\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  [ guard ] / action =  s2 _s\n      ,  s2 _s + event e3  [ guard ] =  s1 _s\n      ,  s2 _s + event e4  / action = X\n    );\n  }\n};\n\ntemplate  class T \nvoid dump_transition() noexcept {\n  auto src_state = std::string{sml::aux::string typename T::src_state {}.c_str()};\n  auto dst_state = std::string{sml::aux::string typename T::dst_state {}.c_str()};\n  if (dst_state ==  X ) {\n    dst_state =  [*] ;\n  }\n\n  if (T::initial) {\n    std::cout    [*] --      src_state   std::endl;\n  }\n\n  std::cout   src_state     --      dst_state;\n\n  const auto has_event = !sml::aux::is_same typename T::event, sml::anonymous ::value;\n  const auto has_guard = !sml::aux::is_same typename T::guard, sml::front::always ::value;\n  const auto has_action = !sml::aux::is_same typename T::action, sml::front::none ::value;\n\n  if (has_event || has_guard || has_action) {\n    std::cout     : ;\n  }\n\n  if (has_event) {\n    std::cout         typeid(typename T::event).name();\n  }\n\n  if (has_guard) {\n    std::cout     [    typeid(typename T::guard).name()    ] ;\n  }\n\n  if (has_action) {\n    std::cout     /     typeid(typename T::action).name();\n  }\n\n  std::cout   std::endl;\n}\n\ntemplate  template  class...  class T, class... Ts \nvoid dump_transitions(const T Ts... ) noexcept {\n  int _[]{0, (dump_transition Ts (), 0)...};\n  (void)_;\n}\n\ntemplate  class SM \nvoid dump(const SM ) noexcept {\n  std::cout    @startuml    std::endl   std::endl;\n  dump_transitions(typename SM::transitions{});\n  std::cout   std::endl    @enduml    std::endl;\n}\n\nint main() {\n  sml::sm plant_uml  sm;\n  dump(sm);\n}   https://raw.githubusercontent.com/boost-experimental/sml/master/example/plant_uml.cpp", 
            "title": "Plant UML Integration"
        }, 
        {
            "location": "/faq/index.html", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/CHANGELOG/index.html", 
            "text": "[1.1.0] - 2017-XX-XX\n\n\n1.0.1\n - 2016-05-06\n\n\n\n\nAdditions\n\n\nSupport for GCC-6.1\n\n\n\n\n\n\n\n\n1.0.0\n - 2016-01-28\n\n\n\n\nInitial version", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/index.html#110-2017-xx-xx", 
            "text": "", 
            "title": "[1.1.0] - 2017-XX-XX"
        }, 
        {
            "location": "/CHANGELOG/index.html#101-2016-05-06", 
            "text": "Additions  Support for GCC-6.1", 
            "title": "1.0.1 - 2016-05-06"
        }, 
        {
            "location": "/CHANGELOG/index.html#100-2016-01-28", 
            "text": "Initial version", 
            "title": "1.0.0 - 2016-01-28"
        }, 
        {
            "location": "/TODO/index.html", 
            "text": "https://waffle.io/boost-experimental/sml", 
            "title": "TODO"
        }
    ]
}